<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [列表 与 元组](#%E5%88%97%E8%A1%A8-%E4%B8%8E-%E5%85%83%E7%BB%84)
    - [常用api](#%E5%B8%B8%E7%94%A8api)
    - [数组操作](#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C)
    - [分片](#%E5%88%86%E7%89%87)
    - [序列相加](#%E5%BA%8F%E5%88%97%E7%9B%B8%E5%8A%A0)
    - [元素操作](#%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C)
- [元组 不可变序列](#%E5%85%83%E7%BB%84-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 列表 与 元组

#### 常用api

- len
- max
- min
- cmp 比较两个值
- append 追加元素进list，会修改原list值，而不是返回一个新的值
- count 统计元素出现次数
- extend 连接list // [1,2,3].extend([1,2]) => [1,2,3,1,2] 次操作将会修改被拓展的原始数组，尽量使用list加操作来完成此操作，避免修改原始值
- index 获取出元素在list中第一次出现的位置，类似于js中的indexOf函数，返回索引号,如果没有搜索到会直接异常
- insert(index,val/vals) // 插入值
- pop 弹出值，返回被弹出的值，如果需要入栈可以使用append
- remove 移除第一个匹配项 // [1,2,4,2].remove(2) // [1,4,2]
- revese 你想整个序列，改变原始序列，不返回值
- sort 对list进行排序，会改变原始值，返回空值


列表可修改，而元组不可更改

ps：字符串下标索引与其他语言一致，负值索引为反向索引，从尾部开始索引 -1代表字符串最后一个位置

#### 数组操作

数字本身可以直接参与乘法运算以及加法运算，如下：

    buff = ['th'] * 2 + ['add']
    buff // ['th','th','add']

#### 分片

py中分片非常方便使用起始与结束的下标即可完成分片获取：

    buff = '123456';
    buff[1:3] // 234
    buff = ['1','2','3']
    buff[1:2] // ['2','3']

ps:如果缺省某一个边界，则对应方向的边界取边界值，左侧0，右侧为列表最大索引值

ps2:右侧边界索引的位置不会出现在最后的结果中，左侧的边界则会，意思就是区间是一个左闭右开的区间 数学定义：[leftIndex,rightIndex)

获取结尾部分集合：

    buff[-3:] // 使用负值进行反向索引，概念同前

其实分片的概念基本与数学意义上的区间概念一致，指定区间左侧起始位置以及结束位置即可确定一个准确的区间，指定区间的某一侧，另一侧默认为边界值

ps：如果需要复制整个序列，只需要将区间两边的边界都省略即可

*步长：默认步为1，可以显示指定步长值，用于做一些高级筛选*

栗子如下：

    buff = [1,2,3,4,5,6]
    buff[0,8,2] // [1,3,5]
    buff[0,8,3] // [1,4]

ps:步长可以是负值，含义为自右向左提取值：

    buff = [1,2,3,4,5,6,7,8]
    buff[10:0:-2] // [8,6,4,2]    

重点：反向取值时，需要注意边界也需要进行对调，例如逆序一个序列可以像下面的写法：

    buff = [1,2,3]
    buff[::-1]
    buff[3:0:-1] // 注：左右边界互换位置，否则区间将会是空


#### 序列相加

序列相加，数列乘法可以直接操作：

    [1,2,3] + [4,5,6] // [1,2,3,4,5,6]
    ['th'] * 2 // ['th','th']

> 空值

python中内置的空值并非null undefined而是None，例子：

    # 新建一个占据10个空位的空序列
    [None] * 10

> 包含检查

检查值是否存在于序列之中：

    str = '1234'
    '234' in str // True
    '11' in str // False
    buff = ['jack','rose']
    'jack' in buff // True

#### 元素操作

赋值： 
    
    buff[0] = something

删除： 
    
    del buff[0] // 删除后列表中其他元素顺序前移

分片替换：

    buff = list('12345')
    buff[1:] = '3' // [1,3]
    # 此处所有的赋值，不管边界如何均为替换赋值，不论长度如何，因此可以实现插入，删除等变种操作
    # 插入,但不删除任何元素
    buff[1:1] = ‘123’ // 这将在下标为1的元素后面添加123，但又不会删除buff[1]本身


ps：个人觉得此处的处理思想应坚持函数式编程思想，不去修改原始值，而是操作后返回一个新的值

## 元组 不可变序列

类似于js中的对象字面量 =》 (1,2,3)



