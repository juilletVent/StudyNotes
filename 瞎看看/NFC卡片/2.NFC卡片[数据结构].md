<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [卡片数据结构](#%E5%8D%A1%E7%89%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
- [详细的数据结构](#%E8%AF%A6%E7%BB%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
  - [0 号扇区 0 号区块](#0-%E5%8F%B7%E6%89%87%E5%8C%BA-0-%E5%8F%B7%E5%8C%BA%E5%9D%97)
  - [关于 0 扇区 ID 的校验位](#%E5%85%B3%E4%BA%8E-0-%E6%89%87%E5%8C%BA-id-%E7%9A%84%E6%A0%A1%E9%AA%8C%E4%BD%8D)
  - [每个扇区的 3 号区块](#%E6%AF%8F%E4%B8%AA%E6%89%87%E5%8C%BA%E7%9A%84-3-%E5%8F%B7%E5%8C%BA%E5%9D%97)
  - [三号区块的访问控制字节](#%E4%B8%89%E5%8F%B7%E5%8C%BA%E5%9D%97%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%97%E8%8A%82)
- [全球通用的 13 个默认密码](#%E5%85%A8%E7%90%83%E9%80%9A%E7%94%A8%E7%9A%84-13-%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 卡片数据结构

一张卡最小的读写大小称之为一个区块，大小为 16 个字节，总共 64 个区块，总大小为 1Kb；每 4 个区块构成一个整体称之为一个扇区，总计 16 个扇区

每个扇区的 0，1，2 号区块为数据区块，3 号区块为秘钥与控制区块；秘钥区块存放了该扇区的访问秘钥以及权限控制读写位，不可随意更改，否则可能导致该区块 永久死区，如果是 0 号扇区，3 区块被随意修改，可能导致卡片报废；

第 0 个扇区第 0 个区块存放了关于卡本身的描述信息，不可随意修改，否则可能导致卡片报废。

## 详细的数据结构

### 0 号扇区 0 号区块

```
['0x1c', '0x9d', '0x8d', '0x32', '0x3e', '0x8', '0x4', '0x0', '0x62', '0x63', '0x64', '0x65', '0x66', '0x67', '0x68', '0x69']

|-------- 四字节卡片ID -------- |
                               |--- 一字节卡片ID校验位：一定要写对，否则卡片报废 ---|
                                         |--- 两字节卡片类型信息，不要动就对了 ---|
                                                      |--- 一字节0，不知道什么意思，不要动就对了 ---|
                                                              |---              没啥用，随便占位写就行了                    ---|
```

如果想修改卡片 ID，请确认你的卡片是否支持读写 0 扇区 0 区块，CUID 卡片可直接读写，UID 以及 UFUID 实测无法直接写入，CUID 可直接写入，并可以反复擦写，但是一定要注意卡片的校验位不要弄错，弄错卡片就报废；卡片类型信息不要动，固定 0x8 0x4 就行了，后面紧接的 0x0 最好也不要动，观察到手边的卡片，这几位都是一样的，还是不要动为好

### 关于 0 扇区 ID 的校验位

校验位的值为四字节 ID 每个字节值相异或取得，计算方法如下：

```javascript
const key = [0x1c, 0x9d, 0x8d, 0x32];
let checkCode = key[0];

for (let i = 1; i < key.length; i++) {
  checkCode ^= key[i];
}

// 0x3e
console.log(checkCode);
```

### 每个扇区的 3 号区块

每个扇区的 3 号区块为该扇区的读写访问控制区，存放的数据，指导了该扇区哪些数据由什么秘钥操作，能进行什么操作;每个扇区有两组秘钥，秘钥 A 与秘钥 B，他们有什么能力要看控制区块的配置；默认情况下两个秘钥的权限是基本一致的，有些许差别，不赘述

```
['0xff', '0xff', '0xff', '0xff', '0xff', '0xff' '0xff', '0x7', '0x80', '0x69', '0xff', '0xff', '0xff', '0xff', '0xff', '0xff']
|------------ 六个字节的秘钥A ------------------|
                                               |---- 四个字节的访问控制配置 ---|
                                                                             |------------ 六个字节的秘钥B ------------------|
```

但是当你用传感器模块而不是手机进行卡片读取时，可能会发现读取到的数据是这样的：

```
# 实际使用PN532读取出来的结构
['0x0', '0x0', '0x0', '0x0', '0x0', '0x0', '0xff', '0x7', '0x80', '0x69', '0xff', '0xff', '0xff', '0xff', '0xff', '0xff']
```

这是因为区段控制配置导致的，所有的配置都不允许读取秘钥 A 的值，所以你看到秘钥 A 的值就是六个 0x0；

默认情况下 Akey 与 Bkey 基本等效，都具备该扇区的读写权限，如果想要修改秘钥，直接修改 3 号区块即可，但是要小心不要动到三号区块的控制字节，除非你知道你在干什么

### 三号区块的访问控制字节

默认的控制字段配置为:~ '0xff', '0x7', '0x80', '0x69' ~ ,实际上只有前三个是实际使用了的，第四个可以不管，字节按位进行控制定义：

|        |   7   |   6   |   5   |   4   |   3   |   2   |   1   |   0   |
| :----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 字节 6 | C23_b | C22_b | C21_b | C20_b | C13_b | C12_b | C11_b | C10_b |
| 字节 7 |  C13  |  C12  |  C11  |  C10  | C33_b | C32_b | C31_b | C30_b |
| 字节 8 |  C33  |  C32  |  C31  |  C30  |  C23  |  C22  |  C21  |  C20  |
| 字节 9 | 忽略  | 忽略  | 忽略  | 忽略  | 忽略  | 忽略  | 忽略  | 忽略  |

**重点：携带了\_b 的位实际使用时是需要进行取反的，一定要注意**

以 FF078069 默认控制位为例，我们将 FF078069 的 16 进制转化为 2 进制如下：

```
FF = 11111111 07 = 00000111 80 = 10000000 69 = 忽略
```

将得到的二进制填入上面的定义表格的到：

|        |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
| :----: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 字节 6 |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |
| 字节 7 |  0  |  0  |  0  |  0  |  0  |  1  |  1  |  1  |
| 字节 8 |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |

将所有带有\_b 的定义位进行取反得到最终的控制配置：

|        |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
| :----: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 字节 6 |  0  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |
| 字节 7 |  0  |  0  |  0  |  0  |  1  |  0  |  0  |  0  |
| 字节 8 |  1  |  0  |  0  |  0  |  0  |  0  |  0  |  0  |

存储每个块的三个控制位定义如下：

|      | 制位 1 | 控制位 2 | 控制位 3 |
| :--: | :----: | :------: | :------: |
| 块 0 |  C10   |   C20    |   C30    |
| 块 1 |  C11   |   C21    |   C31    |
| 块 2 |  C12   |   C22    |   C32    |
| 块 3 |  C13   |   C23    |   C33    |

重点来了，0-2 号区块的权限映射表与 3 号区块的权限映射表不一样，下面的是 0-2 号区块的权限控制表：

| 控制位(C1X) | 控制位(C2X) | 控制位(C3X) |  Read   |  Write  | Increment | Decrement,Transfer,Restore |
| :---------: | :---------: | :---------: | :-----: | :-----: | :-------: | -------------------------- |
|      0      |      0      |      0      | KeyA\|B | KeyA\|B |  KeyA\|B  | KeyA\|B                    |
|      0      |      1      |      0      | KeyA\|B |  Never  |   Never   | Never                      |
|      1      |      0      |      0      | KeyA\|B |  KeyB   |   Never   | Never                      |
|      1      |      1      |      0      | KeyA\|B |  KeyB   |   KeyB    | KeyA\|B                    |
|      0      |      0      |      1      | KeyA\|B |  Never  |   Never   | KeyA\|B                    |
|      0      |      1      |      1      |  KeyB   |  KeyB   |   Never   | Never                      |
|      1      |      0      |      1      |  KeyB   |  Never  |   Never   | Never                      |
|      1      |      1      |      1      |  Never  |  Never  |   Never   | Never                      |

下面是 3 号区块的权限控制表：

| 控制位(C13) | 控制位(C23) | 控制位(C33) | KeyA-Read | KeyA-Write | 存取控制-Read | 存取控制-Write | KeyB-Read | KeyB-Write |
| :---------: | :---------: | :---------: | :-------: | :--------: | :-----------: | :------------: | --------- | ---------- |
|      0      |      0      |      0      |   Never   |  KeyA\|B   |    KeyA\|B    |     Never      | KeyA\|B   | KeyA\|B    |
|      0      |      1      |      0      |   Never   |   Never    |    KeyA\|B    |     Never      | KeyA\|B   | Never      |
|      1      |      0      |      0      |   Never   |    KeyB    |    KeyA\|B    |     Never      | Never     | KeyB       |
|      1      |      1      |      0      |   Never   |   Never    |    KeyA\|B    |     Never      | Never     | Never      |
|      0      |      0      |      1      |   Never   |  KeyA\|B   |    KeyA\|B    |    KeyA\|B     | KeyA\|B   | KeyA\|B    |
|      0      |      1      |      1      |   Never   |    KeyB    |    KeyA\|B    |      KeyB      | Never     | KeyB       |
|      1      |      0      |      1      |   Never   |   Never    |    KeyA\|B    |      KeyB      | Never     | Never      |
|      1      |      1      |      1      |   Never   |   Never    |    KeyA\|B    |     Never      | Never     | Never      |

可见块 0，块 1，块 2 通过密钥 A 或者密钥 B 认证后可读，可写，可进行加值和减值操作。块 3 密钥 A 不可读，但可通过认证密钥 A 或 B 修改。验证密钥 A 或者密钥 B 后，可读可改写存取控制。验证密钥 A 或者密钥 B 后，可读可改写 B 密码。

## 全球通用的 13 个默认密码

```
['0xff', '0xff', '0xff', '0xff', '0xff', '0xff']
['0x00', '0x00', '0x00', '0x00', '0x00', '0x00']
['0xa0', '0xa1', '0xa2', '0xa3', '0xa4', '0xa5']
['0xb0', '0xb1', '0xb2', '0xb3', '0xb4', '0xb5']
['0xc0', '0xc1', '0xc2', '0xc3', '0xc4', '0xc5']
['0xd0', '0xd1', '0xd2', '0xd3', '0xd4', '0xd5']
['0xaa', '0xbb', '0xcc', '0xdd', '0xee', '0xff']
['0x1a', '0x2b', '0x3c', '0x4d', '0x5e', '0x6f']
['0x12', '0x34', '0x56', '0x78', '0x9a', '0xbc']
['0x01', '0x02', '0x03', '0x04', '0x05', '0x06']
['0x12', '0x34', '0x56', '0xab', '0xcd', '0xef']
['0xab', '0xcd', '0xef', '0x12', '0x34', '0x56']
['0x4d', '0x3a', '0x99', '0xc3', '0x51', '0xdd']
```
