# 函数

## 默认值

支持参数默认值

使用默认参数时，参数列表不能有同名参数 【感觉没啥意义，谁没事儿干声明两个名字一样的参数】

惰性求值：默认参数取值方式不是一次性求值传入，而是实时计算

栗子：

	let a=1;
	
	func ff(b=a)
		...
	
	ff() => 1
	
	a++
	
	ff() => 2


## 解构赋值

可以与参数名匹配进行对象解构赋值

	function foo({x, y = 5}) {
	  console.log(x, y);
	}
	
	foo({}) // undefined 5
	foo({x: 1}) // 1 5
	foo({x: 1, y: 2}) // 1 2

带默认值得结构赋值传参

	function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
	  console.log(method);
	}

## 函数 length

返回函数的参数个数，不包含带有默认值的参数，以及第一个默认值参数后所有的其他参数

## 参数独立作用域

在函数声明头部，参数声明具备独立作用域，在全局作用域之上

## 不定参数 rest

引入不定参数 ...args

## 函数内部使用严格模式 

use strict

ES6做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

## 获取函数名

func.name

## Lambda表达式（箭头函数）

箭头函数有几个使用注意点。

（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

**Tips:this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。**

## 尾调用优化

在函数调用自然而然形成的调用栈中，如果某一个函数调用处于调用他的外层函数的最后一步，且内层函数不对外层函数形成闭包，则JS引擎将会优化这次调用，抛弃外层函数的执行上下文，直接使用内层函数的上下文

>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。
注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

## 尾递归优化

结合上面尾调用优化，尾递归的优化原理就是深层调用的时候JS引擎直接抛弃外层调用上下文，所以不会出现stack overflow的情况，由于是递归调用，所以不存在闭包问题


## 调用优化的使用场景

函数调用优化只在严格模式下进行，正常模式无效

这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。

- func.arguments：返回调用时函数的参数。
- func.caller：返回调用当前函数的那个函数。

尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。

## 函数定义/调用逗号

ES2017 允许函数的最后一个参数有尾逗号（trailing comma）