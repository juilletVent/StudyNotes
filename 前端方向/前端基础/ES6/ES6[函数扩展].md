<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [函数](#%E5%87%BD%E6%95%B0)
  - [默认值](#%E9%BB%98%E8%AE%A4%E5%80%BC)
  - [解构赋值](#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC)
  - [函数 length](#%E5%87%BD%E6%95%B0-length)
  - [参数独立作用域](#%E5%8F%82%E6%95%B0%E7%8B%AC%E7%AB%8B%E4%BD%9C%E7%94%A8%E5%9F%9F)
  - [不定参数 rest](#%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0-rest)
  - [函数内部使用严格模式](#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F)
  - [获取函数名](#%E8%8E%B7%E5%8F%96%E5%87%BD%E6%95%B0%E5%90%8D)
  - [Lambda表达式（箭头函数）](#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0)
  - [尾调用优化](#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96)
  - [尾递归优化](#%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96)
  - [调用优化的使用场景](#%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)
  - [函数定义/调用逗号](#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E8%B0%83%E7%94%A8%E9%80%97%E5%8F%B7)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 函数

## 默认值

支持参数默认值

使用默认参数时，参数列表不能有同名参数 【感觉没啥意义，谁没事儿干声明两个名字一样的参数】

惰性求值：默认参数取值方式不是一次性求值传入，而是实时计算

栗子：

	let a=1;
	
	func ff(b=a)
		...
	
	ff() => 1
	
	a++
	
	ff() => 2


## 解构赋值

可以与参数名匹配进行对象解构赋值

	function foo({x, y = 5}) {
	  console.log(x, y);
	}
	
	foo({}) // undefined 5
	foo({x: 1}) // 1 5
	foo({x: 1, y: 2}) // 1 2

带默认值得结构赋值传参

	function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
	  console.log(method);
	}

## 函数 length

返回函数的参数个数，不包含带有默认值的参数，以及第一个默认值参数后所有的其他参数

## 参数独立作用域

在函数声明头部，参数声明具备独立作用域，在全局作用域之上

## 不定参数 rest

引入不定参数 ...args

## 函数内部使用严格模式 

use strict

ES6做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

## 获取函数名

func.name

## Lambda表达式（箭头函数）

箭头函数有几个使用注意点。

（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。

（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

**Tips:this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。**

## 尾调用优化

在函数调用自然而然形成的调用栈中，如果某一个函数调用处于调用他的外层函数的最后一步，且内层函数不对外层函数形成闭包，则JS引擎将会优化这次调用，抛弃外层函数的执行上下文，直接使用内层函数的上下文

>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。
注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

## 尾递归优化

结合上面尾调用优化，尾递归的优化原理就是深层调用的时候JS引擎直接抛弃外层调用上下文，所以不会出现stack overflow的情况，由于是递归调用，所以不存在闭包问题


## 调用优化的使用场景

函数调用优化只在严格模式下进行，正常模式无效

这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。

- func.arguments：返回调用时函数的参数。
- func.caller：返回调用当前函数的那个函数。

尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。

## 函数定义/调用逗号

ES2017 允许函数的最后一个参数有尾逗号（trailing comma）