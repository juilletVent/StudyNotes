# 函数基础

函数实际上是对象。每个函数都是 Function 类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。

## 函数定义

```js
// 直接定义
function Fn() {}
// 函数表达式
const a = function () {};
// 箭头函数/Lamda
const b = () => {};
// 解释性定义
const c = new Function("param1", "param2", "return param1 + param2");
```

### 箭头函数

箭头函数的特点：

- 不能使用 arguments、 super 和 new.target
- 不能用作构造函数
- 箭头函数没有 prototype 属性

```js
let arrowSum = (a, b) => {
  return a + b;
};
```

### 函数名

函数对象都具备 name 属性，存放 function 的字符串标示符描述，函数表达式在不对外赋值的情况下，name 属性为空，如果声明时采用匿名形式并对变量进行了赋值，则函数对象的 name 为变量名字符串，如果采用命名表达式，则名称为实际的函数命名，如果使用 Function 构造函数创建函数，则 name 为：`anonymous`固定值：

```js
const fnName = () => {};
fnName.name; // fnName
const fn = function hasName() {};
fn.name; // hasName
(() => {}).name; // ''
const conFn = new Function();
conFn.name; // anonymous
```

### 函数参数

在 ECMAScript 中，函数的参数与其他语言，有很大不同，函数中除了函数声明的形式参数外，还有一个隐含的实际参数数组引用，`arguments`，与显示声明的形式参数一一对应，下面是关于他们之间的一些特点（非严格模式下的，所以看看就好）：

- 声明的形式参数与隐式参数数组中的值是同步的：修改了之后会同步反应在另外一边（严格模式下修改 arguments 参数数组会报错）
- 如果修改 arguments 数组时超过了实际参数个数，则第一条的同步作用将不会生效
- 形式参数与 arguments 之间虽然值是同步的，但是他们并不是引用的同一片内存区域，只是只同步而已
- 如果函数定义使用的是箭头函数，则函数内 arguments 是不可用的

**重点：ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。**

## 关于重载

ECMAScript 中没有重载的直接实现，由于函数本身根本就没有函数签名这么一说，自然也就没有重载，如果函数进行了重名定义，则后定义后覆盖先前的定义。

这里理解成函数表达式赋值给了某一个局部变量是一样的：再次给该变量赋值当然是后赋予的值覆盖之前的值

## 默认参数

ES5 之前，不支持默认参数，只能通过参数是否为 undefined 来判断，ES6 及之后，可以直接在形式参数上定义默认参数值，所有的必选参数必须在默认参数前面

_Tips：函数默认值可以使用表达式，该表达式的结果使用延迟运算，只在实际调用发生时进行计算_

默认参数可以进行前向引用：后面的参数可以引用前面的参数进行默认赋值，规则遵循变量的 TDZ（临时性死区）规则，因此只能进行前向引用，也不能引用函数作用域内的变量定义

## 参数扩展/收集（可变参数）

原先进行参数扩展传入时可能只能使用如下这种代码：

```js
// ES6之前
fn.apply(null, [1, 2, 3, 4]);
// ES6之后
fn(...[1, 2, 3, 4]);
```

参数收集，类似于 c 语言中的可变参数，可将剩余的参数全部放入一个形式参数中，接收形式为数组：

```js
function fn(...rest) {}
```

## 函数声明与函数表达式

函数声明存在声明提升，会将函数声明提升至当前执行上下文顶部，因此使用函数声明进行声明的函数可以在声明之前使用，函数声明的限制作用域为函数作用域；

函数表达式不存在声明提升，作用域为块级作用域；

## 函数/函数内部的特殊值

### arguments

对所有实际参数的收集引用，箭头函数定义的函数内部，此变量不可用，arguments 是一个类数组对象，

- 其上还有一个特殊属性：`callee`索引的是当前 arguments 所在的函数，如果正在编写递归调用，请使用 arguments.callee 进行自引用调用，不要使用函数名；还可以用这个属性的 length 来确定行参个数，当然，使用函数名也可以
- fn.caller：caller 在函数对象上，执行时访问这个属性可以确定调用者是谁

### this 函数执行上下文

它在标准函数和箭头函数中有不同的行为，在标准函数中， this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在
网页的全局上下文中调用函数时， this 指向 windows）；在箭头函数中， this 引用的是定义箭头函数的上下文

### new.target

如果函数正常调用则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。

### caller

fn.caller 这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null，如果要降低耦合度，则可以通过 arguments.callee.caller 来引用

**Tips：在严格模式下访问 arguments.callee**
