<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

**Table of Contents** _generated with [DocToc](https://github.com/thlorenz/doctoc)_

- [定型 Array](#定型-array)
  - [历史](#历史)
  - [ArrayBuffer](#arraybuffer)
  - [DataView](#dataview)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 定型 Array

## 历史

在 WebGL 的早期版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。图形驱动程序 API 通常不需要以 JavaScript 默认双精度浮点格式传递给它们的数值，而这恰恰是 JavaScript 数组在内存中的格式。因此，每次 WebGL 与 JavaScript 运行时之间传递数组时， WebGL 绑定都需要在目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式，而这些要花费很多时间

## ArrayBuffer

ArrayBuffer 类型理解为一个可读写的内存块（不可以直接读写，只是承载），读写需要透过 DataView 进行（对二进制数据进行解释），特性如下：

- 分配后长度不可变更
- 如果分配失败，抛出异常
- 自动回收，无需手动释放
- 最大可分配值受制于 Number.MAX_SAFE_INTEGER
- 分配后，统一初始化为内存区块为 全 0

简单初始化与操作：

```js
const buf = new ArrayBuffer(16); // 在内存中分配 16 字节
alert(buf.byteLength); // 16

const buf1 = new ArrayBuffer(16);
const buf2 = buf1.slice(4, 12);
alert(buf2.byteLength); // 8
```

_Tips:SharedArrayBuffer 是 ArrayBuffer 的一个变体，可以无须复制就在执行上下文间传递它。_

## DataView

DataView 用于对 ArrayBuffer 进行读写，是读写的一种操作手段（解释手段），读写时必须指定数据格式：

| ElementType | 字 节 | 说 明           | 等价的 C 类型 | 值的范围                     |
| ----------- | ----- | --------------- | ------------- | ---------------------------- |
| Int8        | 1     | 8 位有符号整数  | signed        | char 128~127                |
| Uint8       | 1     | 8 位无符号整数  | unsigned      | char 0~255                   |
| Int16       | 2     | 16 位有符号整数 | short         | -32 768~32 767               |
| Uint16      | 2     | 16 位无符号整数 | unsigned      | short 0~65 535               |
| Int32       | 4     | 32 位有符号整数 | int           | -2 147 483 648~2 147 483 647 |
| Uint32      | 4     | 32 位无符号整数 | unsigned int  | 0~4 294 967 295              |
| Float32     | 4     | 32 位 IEEE-754  | 浮点数 float  | -3.4e+38~+3.4e+38            |
| Float64     | 8     | 64 位 IEEE-754  | 浮点数 double | -1.7e+308~+1.7e+308          |
