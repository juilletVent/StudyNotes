## 历史

ECMAScript 中 Promise 的实现是基于 Promise/A+实现，该规于 2021 年有 Promise/A+组织自 Promise/A 规范 fork，并最终作为 ECMAScript 的 Promise 实现规范

## Promise 特点

- Promise 内部状态对外部不可见：为了避免根据读取到的期约状态，以同步方式处理期约对象
- Promise 内部状态对外部来说不可更改，且对内部来说，也只能由 peding => resolve 或 peding=>reject 变化一次，变化后，就不能再次变化了：原因同上，主要是为了隔离代码
- Promise 中 reject 时会产生一个错误，这个错误是异步错误不能通过 try/catch 捕捉，只能通过错误处理程序或 Promise API catch 进行处理

> 拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此， try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。

## Promise API

- Promise.resolve 创建一个已经 resolved 的 Promise
- Promise.reject 创建一个已经 rejected 的 Promise
- Promise.prototype.catch 捕获 Promise 中没有处理的异常
- Promise.prototype.finally 为 Promise 添加后处理回调,这个处理程序在期约转换为解决或拒绝状态时都会执行；在此 API 中返回一个新的 Promise 实例，并在当前方法后继续接 then 调用，将接收不到返回的 Promise 返回的值，而是之前 Promise resolved 的值

```js
Promise.resolve("a")
  .finally(() => Promise.resolve("b"))
  .then((data) => {
    // finally之后不会在响应后续的Promise返回值
    console.log(data); // a
  });
```

## 执行时机

Promise 的初始化注册函数为同步执行，相关 API（then/catch/finally）执行任务都会推进执行队列，均为异步执行，

如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行
