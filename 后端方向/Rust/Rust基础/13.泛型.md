<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

**Table of Contents** _generated with [DocToc](https://github.com/thlorenz/doctoc)_

- [泛型基础用法](#%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 泛型基础用法

```rust
// 泛型结构体
struct Point<T> {
    x: T,
    y: T,
}

// 为所有泛型类型实现方法
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x // 返回x的引用
    }

    fn print() {
        println!("this is any type version.")
    }
}

// 为特定类型实现方法
// 注意：多个 impl 块，不能重复实现相同方法，哪怕泛型类型不同，不能借助特化类型来实现函数重载的效果
impl Point<i32> {
    fn print() {
        println!("this is i32 version.")
    }
}

// 多个泛型参数
struct Point2<T, P> {
    x: T,
    y: P,
}

// 泛型枚举
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

## Const 泛型（Rust 1.51 新增）

考虑`[i32; 2]` 和 `[i32; 3]` 是不同的数组类型，考察下面的案例：

```rust
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(arr);

    let arr: [i32; 2] = [1, 2];
    display_array(arr); // 此处会报错：mismatched types expected an array with a size of 3, found one with a size of 2
}

fn display_array(arr: [i32; 3]) {
    println!("{:?}", arr);
}
```

如果当前场景可以使用数组切片的话，那么这个问题很好解决，使用切片引用传递即可：

```rust
fn main() {
    let arr: [i32; 3] = [1, 2, 3];
    display_array(&arr);

    let arr: [i32; 2] = [1, 2];
    display_array(&arr);
}

fn display_array<T: std::fmt::Debug>(arr: &[T]) {
    println!("{:?}", arr);
}
```

但是如果当前场景无法传递切片引用，或者就是要消耗掉数组的所有权，那么就需要使用 Const 泛型来解决这个问题：

```rust
fn display_array<T: std::fmt::Debug, const N: usize>(arr: [T; N]) {
    println!("{:?}", arr);
}
```

此时，在随意传入任意长度的数组时，编译器会自动推导出数组的长度，从而避免类型不匹配的问题。

### const fn

函数一般在运行时调用，如果函数可以在编译时运行（比如计算单纯为了方便计算某些常量），那么就可以使用 const fn 来实现，这些函数将在编译期间就被执行，从而避免运行时开销。

```rust
// 结合 Const 泛型，可以实现编译时计算常量
struct Buffer<const N: usize> {
    data: [u8; N],
}

const fn compute_buffer_size(factor: usize) -> usize {
    factor * 1024
}

fn main() {
    const SIZE: usize = compute_buffer_size(4); // 在编译时计算常量，运行时这里将会被替换为常量
    let buffer = Buffer::<SIZE> {
        data: [0; SIZE],
    };
    println!("Buffer size: {} bytes", buffer.data.len());
}
```

## 默认的 Sized Trait

函数的泛型实现默认增加了一个泛型约束：`Sized`，表示该泛型类型的大小是已知的，这是编译器的默认行为：

```rust
fn generic<T>(t: T) {
    // --snip--
}
// 实际上等价于
fn generic<T: Sized>(t: T) {
    // --snip--
}
```

可以用特殊语法来放款这个限制：

```rust
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}

```

`?Sized` trait bound 与 `Sized` 相对；也就是说，它可以读作 “T 可能是也可能不是 Sized 的”。这个语法只能用于 Sized ，而不能用于其他 trait。

另外注意我们将 t 参数的类型从 T 变为了 &T：因为其类型可能不是 Sized 的，所以需要将其置于某种指针之后。在这个例子中选择了引用。因为函数参数使用栈进行传递，必须是可以 Sized 的，所以需要使用引用。
