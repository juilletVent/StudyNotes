## 基础使用

```rust
use std::{
    thread::{self, sleep},
    time::Duration,
};

fn main() {
    thread::spawn(|| {
        for i in 0..10 {
            println!("print num {} from spawned thread.", i);
            sleep(Duration::from_millis(10));
        }
    });

    for i in 0..10 {
        println!("print num {} from main thread.", i);
        sleep(Duration::from_millis(5));
    }
    println!("Main thread done !");
}
```

可以观察到，主线程和子线程是交替执行的，当主线程执行完之后，子线程无论是否执行完，都会被主线程结束掉。

### 等待子线程执行完毕

```rust
// 等待子线程执行完毕
let sub_thread = thread::spawn(|| {
    for i in 0..10 {
        println!("print num {} from spawned thread.", i);
        sleep(Duration::from_millis(20));
    }
});

sub_thread.join().unwrap();
```

### 子线程捕获变量

最佳实践：始终使用 move 捕获变量。

```rust
let x = 1;
let y = 2;

thread::spawn(move || {
    println!("x: {}", x);
    println!("y: {}", y);
});
```

## 使用消息传递在多线程之间转移数据

```rust
use std::{sync::mpsc, thread};
fn main() {
    // 创建一个通道，tx 是发送者，rx 是接收者
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        // 发送数据
        tx.send(val).unwrap();
    });

    // 阻塞式接收数据
    let received = rx.recv().unwrap();
    // 非阻塞式接收数据，返回一个Option，如果没有数据可以读取，则返回Some(Empty)
    let received_opt = rx.try_recv().unwrap();
    println!("Got: {}", received);
}
```

如果发送的数据实现了 Copy Trait 则发送时直接进行 Copy，如果没有实现，则进行所有权转移。

### 同步通道

默认情况下，发送数据是异步的，发送数据不会阻塞执行，被发送的值被送入缓冲队列，接收者可以异步接收，如果希望使用同步通道：

```rust
use std::{sync::mpsc, thread, time::Duration};

fn main() {
    // 新建一个同步通道，传入N，表明内部缓冲区长度，如果缓冲区满了则发送时必须等待接收侧接收才能继续执行
    // 传入 0，则表示同步通道，发送者必须等待接收者接收才能继续执行
    let (tx, rx) = mpsc::sync_channel(0);

    let handle = thread::spawn(move || {
        println!("发送之前");
        tx.send(114514).unwrap();
        println!("发送之后");
    });

    println!("主线程睡觉前");
    thread::sleep(Duration::from_secs(2));
    println!("主线程睡觉后");

    println!("主线程接收数据：{}", rx.recv().unwrap());
    handle.join().unwrap();
}
```

### 连续发送与迭代器使用

```rust
use std::{
    sync::mpsc,
    thread::{self, sleep},
    time::Duration,
};
fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            sleep(Duration::from_secs(1));
        }
    });

    // 接收端会阻塞，直到发送端发送值，如果所有发送端都关闭了，则迭代器将会终止
    for received in rx {
        println!("Got: {}", received);
    }
}

```

### 创建多个发送者

```rust
let (tx, rx) = mpsc::channel();
// 方式一
let tx1 = mpsc::Sender::clone(&tx);
// 方式二
let tx2 = tx.clone();
```

### 一个浅浅的坑

```rust
use std::sync::mpsc;
fn main() {

    use std::thread;

    let (send, recv) = mpsc::channel();
    let num_threads = 3;
    for i in 0..num_threads {
        let thread_send = send.clone();
        thread::spawn(move || {
            thread_send.send(i).unwrap();
            println!("thread {:?} finished", i);
        });
    }

    // 根据NLL规则，send的生命周期在for循环结束时结束，但是NLL并不是实际上的变量作用域
    // send 的词法作用域是整个main函数期间，因此下面的for循环永远不对结束，因为send没有被drop

    for x in recv {
        println!("Got: {}", x);
    }
    println!("finished iterating");
}
```

## 共享状态的并发

简单使用互斥体加原子 Arc 多所有权类型实现多线程共享状态：

```rust
use std::{
    sync::{Arc, Mutex},
    thread,
};
fn main() {
    // 使用 Arc 实现多线程多所有权，Mutex 实现互斥锁
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        // 克隆 counter 的引用
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            // 获取 counter 的互斥锁，num 类型为 MutexGuard，当离开作用域时，会自动drop，释放锁
            let mut num: std::sync::MutexGuard<'_, i32> = counter.lock().unwrap();
            *num += 1;
            // num drop，释放锁
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("counter = {:?}", *counter.lock().unwrap());
}
```

## Sync trait 和 Send trait

任何完全由 Sync/Send 类型组成的复合类型都会被自动标记为 Sync/Send。除了我们在第 19 章将会讨论到的裸指针，几乎所有的原生类型都满足 Sync/Send 约束。

如果手动实现这两个 Trait，编译器将允许你完成相关的数据空闲操作，但是数据结构本身不是线程安全的，线程安全完全交给你自己控制。

## RwLock 读写锁

读写锁可以控制多个读线程同时访问数据，但是写线程独占访问数据：

1. 同时允许多个读，但最多只能有一个写
2. 读和写不能同时存在
3. 读可以使用 read、try_read，写 write、try_write, 在实际项目中，try_xxx 会安全的多

```rust
use std::sync::RwLock;

fn main() {
    let lock = RwLock::new(5);

    // 同一时间允许多个读
    {
        let r1 = lock.read().unwrap();
        let r2 = lock.read().unwrap();
        assert_eq!(*r1, 5);
        assert_eq!(*r2, 5);
    } // 读锁在此处被drop

    // 同一时间只允许一个写
    {
        let mut w = lock.write().unwrap();
        *w += 1;
        assert_eq!(*w, 6);

        // 以下代码会阻塞发生死锁，因为读和写不允许同时存在
        // 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中
        // let r1 = lock.read();
        // println!("{:?}",r1);
    }// 写锁在此处被drop
}
```

## MPMC 多发多收模式

第三方库：

- crossbeam-channel, 老牌强库，功能较全，性能较强，之前是独立的库，但是后面合并到了 crossbeam 主仓库中
- flume, 官方给出的性能数据某些场景要比 crossbeam 更好些
