## 使用场景

- switch：必须穷尽所有模式，缺省模式使用：`_`
- if let：条件模式匹配
- while let：循环条件匹配
- for：使用解构（`for (index, value) in v.iter().enumerate()`）
- let：解构赋值（`let (x, y, z) = (1, 2, 3);`）
- 函数参数解构

  ```rust
  fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
  }
  fn main() {let point = (3, 5);
    print_coordinates(&point);
  }
  ```

## 模式的可失败性

### 不可失败

对于函数参数、let、for 循环这些场景，只能接受不可失败模式，因为如果传入可失败模式的话，程序将无法继续执行。

### 可失败

对于`if let` 以及 `while let` 则只接受可失败模式，因为他们在实现时就是处理这模式的。

## 模式匹配

### 字面量

```rust
let x = 1;
match x {
  1 => println!("one"),
  2 => println!("two"),
  3 => println!("three"),
  _ => println!("anything"),
}
```

### 命名变量

```rust
fn main() {
  let x = Some(5);
  let y = 10;
  match x {
    Some(50) => println!("Got 50"),
    // 解构进行命名变量匹配
    Some(y) => println!("Matched, y = {:?}", y),
    _ => println!("Default case, x = {:?}", x),
  }
  println!("at the end: x = {:?}, y = {:?}", x, y);
}
```

### 多重模式

Match 表达式中使用 `|` 来进行多重模式匹配：

```rust
let x = 1;
match x {
  1 | 2 => println!("one or two"),
  3 => println!("three"),
  _ => println!("anything"),
}
```

### 区间匹配

对于某一段的值匹配，可以使用`N...M`来进行值的区间匹配：

```rust
let x = 5;
match x {
  // 左闭右开
  1..5 => println!("one through five"),
  // 闭区间
  5..=10 => println!("one through five"),
  // 较大
  20.. => println!("{} is greater than or equal to 20", n),
  // 较小
  ..100 => println!("{} is between 20 and 100", n),
  _ => println!("something else"),
}
```

### 结构体解构

```rust
struct Point {
  x: i32,
  y: i32,
}
fn main() {
  let p = Point { x: 0, y: 7 };
  let Point { x: a, y: b } = p;
  // let Point { x, y } = p; // 这样也是Ok的
  assert_eq!(0, a);
  assert_eq!(7, b);
}
```

对某些条件进行匹配然后再结构，不满足则不匹配：

```rust
fn main() {
  let p = Point { x: 0, y: 7 };
  match p {
    // 仅 y = 0 匹配
    Point { x, y: 0 } => println!("On the x axis at {}", x),
    // 仅 x = 0 匹配
    Point { x: 0, y } => println!("On the y axis at {}", y),
    // 缺省规则，必定命中
    Point { x, y } => println!("On neither axis: ({}, {})", x, y),
  }
}
```

### 解构枚举

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
fn main() {
    let msg = Message::ChangeColor(0, 160, 255);
    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.")
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {} and in the y direction {}", x, y);
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b)
        }
    }
}

```

## 解构中的值忽略

### \_ 忽略整个值

某些场景下，例如元组，函数形参，Match 匹配的剩余分支下，如果不需要相关参数，则可以使用 \_ 进行占位。

一个需要关注的场景：使用 \_ 解构某些值时，如果解构成功的话，并不会出现值转移与绑定，因此不会发生值移动：

```rust
let s = Some(String::from("Hello!"));
if let Some(_) = s { // 解构成功，但是并未进行值绑定
  println!("found a string");
}
// 由于使用 _ 进行解构绑定，因此 s 并未发生移动，此处可以继续使用
println!("{:?}", s);
```

### 使用 \_ 开头的变量

使用 \_ 创建的变量名，不会触发未使用警告：

```rust
let _x = 5
```

## 使用 .. 忽略剩余的值

在解构某些结构体时，可能只需要一部分的键，剩余的键可能并不需要，可以使用下面的语法：

```rust
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };
match origin {
    // 使用 .. 来忽略结构体剩余的字段
    Point { x, .. } => println!("x is {}", x),

    let numbers = (2, 4, 8, 16, 32);
    match numbers {
        // 元组也是可以使用这种语法的
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        }
    }
}
```

**Tips：但是需要注意的是，在元组中使用时，不能出现解构歧义，否则会引发编译错误，比如下面的例子**

```rust
fn main() {
  let numbers = (2, 4, 8, 16, 32);
  match numbers {
    // 对于这里的匹配，可能存在多种解释，也就是存在歧义，是不能通过编译的
    (.., second, ..) => {
      println!("Some numbers: {}", second)
    },
  }
}
```

## 使用匹配守卫添加额外的条件

在模式匹配时，对匹配添加额外的限定条件：

```rust
let num = Some(4);

match num {
    // 匹配Some变体，并且需要 x > 5 才匹配成功
    Some(x) if x > 5 => println!("x is greater than 5: {}", x),
    // 没有添加匹配守卫
    Some(x) => println!("x is 5 or less: {}", x),
    _ => println!("No value"),
}
```

### 组合使用多重模式

```rust
let x = 4;
let y = false;
match x {
    // if 匹配守卫同时作用于4、5、6三种模式，而不仅仅是6，多重模式的优先级更高
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
}
```

## 使用 @ 绑定

```rust
enum Message {
    Hello { id: i32 },
}
let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello {
        // 使用范围限定解构值范围的时候，并提取对应的值到对应变量中
        id: id_variable @ 3..=7,
    } => {
        println!("Found an id in range: {}", id_variable)
    }
    Message::Hello { id: 10..=12 } => { // 因为使用了值限定条件，此处id并未进行绑定，无法读取
        println!("Found an id in another range")
    }
    // 基础模式匹配，可以读取绑定的值
    Message::Hello { id } => {
        println!("Found some other id: {}", id)
    }
}
```
