## 高级 Trait

### 定义关联类型

```rust
pub trait Iterator {
    // 定义一个关联类型 Item
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

impl Iterator for Counter {
    type Item = i32; // 关联类型 Item 的类型是 i32
    fn next(&mut self) -> Option<Self::Item> {
      // 返回一个 i32 值
      Some(1)
    }
}
```

为什么不使用泛型设计：

因为如果使用泛型设计，那么对于同一个类型的不同的泛型参数，可以实现相同的 trait，那么在执行迭代器时也需要明确指定泛型类型，这会导致代码的复杂性增加，易用性降低。

### 默认泛型与运算符重载

```rust
use std::ops::Add;

fn main() {
    let point_a = Point { x: 0, y: 0 };
    let point_b = Point { x: 1, y: 1 };

    let point_c = point_a + point_b;
    println!("point_c: {:?}", point_c);
}

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// 为 Point 实现 Add trait，此处，Add Trait使用了默认泛型类型，所以不需要显式指定泛型类型
// 完整写法：impl Add<i32> for Point {
impl Add for Point {
    // 设置关联类型
    type Output = Point;
    // 定义加法运算
    fn add(self, rhs: Self) -> Self::Output {
        Point {
            x: self.x + rhs.x,
            y: self.y + rhs.y,
        }
    }
}
```

Add Trait 的完整定义：

```rust
// 默认泛型
trait Add<RHS = Self> {
    type Output;
    fn add(self, rhs: RHS) -> Self::Output;
}
```

### 完全限定语法调用同名函数

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}

fn main() {
    let person = Human;
    person.fly(); // 直接调用，将会调用Human的fly方法

    // 使用限定语法调用指定Trait的实现
    Pilot::fly(&person);
    Wizard::fly(&person);
}
```

另外一个使用完全限定语法消除歧义的关联函数调用案例：

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    pub fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("Animal")
    }
}

fn main() {
    // 直接调用Dog本身的同名关联函数
    println!("A baby dog is called a {}", Dog::baby_name());
    // 使用完全限定语法调用Dog实现的Animal Trait的关联函数
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```

### 超 Trait

当我们想要实现一个 trait，但是这个 trait 依赖于另一个 trait，那么我们可以使用 super trait 来实现。

```rust
use std::fmt;
trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

struct Point {
    x: i32,
    y: i32,
}

// 实现 Display Trait
impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "x: {}, y: {}", self.x, self.y)
    }
}

// 实现 OutlinePrint Trait，因为 OutlinePrint Trait 依赖于 Display Trait，所以需要先实现 Display Trait
impl OutlinePrint for Point {}

fn main() {
    let p = Point { x: 1, y: 2 };
    p.outline_print(); // 调用 OutlinePrint Trait 的 outline_print 方法
}
```

### 使用 newtype 模式在外部类型上实现外部 Trait

“为类型实现 trait”一节中提到过孤儿规则：只有当类型和对应 trait 中的任意一个定义在本地包内时，我们才能够为该类型实现这一 trait。但实际上，你还可以使用 ewtype 模式来巧妙地绕过这个限制：

```rust
use std::fmt;
// 使用元组结构体创建新的类型
struct Wrapper(Vec<String>);

// 为Wrapper实现Display Trait
impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}
fn main() {
    // 使用包装类型
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```

包装类型在运行时是没有开销的，编译时会被优化掉。这个实现会使得包装类型丢失所有内部类型的方法，我们可以通过实现 Deref Trait 来解决这个问题：

```rust
use std::{fmt, ops::Deref};

// 使用元组结构体创建新的类型
struct Wrapper(Vec<String>);

// 为Wrapper实现Display Trait
impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

// 实现Deref trait - 这是关键所在！
impl Deref for Wrapper {
    type Target = Vec<String>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

fn main() {
    // 使用包装类型
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);

    println!("=== 展示Deref的威力 ===");

    // 1. 使用Display trait
    println!("使用Display: {}", w);

    // 2. 显式调用deref() - 你原来的方式
    println!("\n显式调用deref():");
    for item in w.deref() {
        println!("  {}", item);
    }

    // 3. 自动解引用 - Deref的核心功能！
    println!("\n自动解引用 - 直接使用Vec的方法:");
    println!("  长度: {}", w.len()); // 自动调用Vec::len()
    println!("  是否为空: {}", w.is_empty()); // 自动调用Vec::is_empty()
    println!("  第一个元素: {:?}", w.get(0)); // 自动调用Vec::get()

    // 4. 可以直接迭代，使用自动解引用
    println!("\n直接迭代 (自动解引用):");
    for item in w.iter() {
        // 自动调用Vec::iter()
        println!("  {}", item);
    }

    // 5. 使用Vec的其他方法
    println!("\n使用更多Vec方法:");
    println!("  包含'hello': {}", w.contains(&String::from("hello")));

    // 6. 索引访问也可以工作
    println!("  索引访问 w[0]: {}", w[0]);

    // 7. 可以使用Vec的迭代器方法
    println!("\n使用迭代器方法:");
    let uppercase: Vec<String> = w.iter().map(|s| s.to_uppercase()).collect();
    println!("  转大写: {:?}", uppercase);

    println!("\n=== Deref让Wrapper表现得像Vec一样！ ===");
}

```
