## 不安全 Rust

不安全的能力：

- 解引用裸指针
- 调用不安全的函数或方法
- 访问或修改可变静态变量
- 实现不安全 Trait

裸指针与引用、智能指针的区别：

- 允许忽略借用规则，可以同时拥有指向相同位置的不可变和可变指针，或同事拥有多个可变指针
- 不保证指针总是指向有效的内存地址
- 允许为空
- 没有实现任何自动清理功能

### 裸指针

```rust
let mut num = 5;

// 创建裸指针
let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
  // 解引用裸指针
  println!("r1 is: {}", *r1);
  println!("r2 is: {}", *r2);
}
```

使用只能指针来创建裸指针：

```rust
let a: Box<i32> = Box::new(10);
// 需要先解引用a
let b: *const i32 = &*a;
// 使用 into_raw 来创建
let c: *const i32 = Box::into_raw(a);
```

### 调用外部 ABI 函数

```rust
extern "C" {
  fn abs(input: i32) -> i32;
}

unsafe {
  println!("Absolute value of -3 according to C: {}", abs(-3));
}
```

### 导出 Rust 函数

```rust
// 必须禁用Rust的名称修饰，Mangling编译阶段，编译器会修改函数名，这对于导出来说是不可接受的，no_mangle告诉编译器不要修改函数名
#[no_mangle]
pub extern "C" fn call_from_c() {
  println!("Just called a Rust function from C!");
}
```

### 访问全局变量

安全的样例：

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
  println!("name is: {}", HELLO_WORLD);
}
```

不安全的样例：

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    // 演示不同的访问方式
    unsafe {
        // 方式1: 直接打印 - 会创建共享引用 (在新Rust版本中报错)
        // println!("COUNTER: {}", COUNTER);  // 等价于 println!("COUNTER: {}", &COUNTER);

        // 方式2: 先复制值再打印 - 安全
        let counter_value = COUNTER; // 读取值而不创建引用
        println!("COUNTER: {}", counter_value);

        // 方式3: 显式创建引用 - 也会报错
        // let reference = &COUNTER;
        // println!("COUNTER: {}", reference);

        // 方式4: 使用原始指针 - 更底层但安全
        let ptr = std::ptr::addr_of!(COUNTER);
        let value = *ptr;
        println!("通过指针读取: {}", value);
    }
}
```

### 实现不安全 Trait

当某个 trait 中存在至少一个方法拥有编译器无法校验的不安全因素时，我们就称这个 trait 是不安全的。

```rust
unsafe trait Foo {
// 某些方法
}
unsafe impl Foo for i32 {
// 对应的方法实现
}
```

### 访问 union 中的字段

主要用于跟 C 代码进行交互，访问 union 的字段是不安全的，因为 Rust 无法保证当前存储在 union 实例中的数据类型

```rust
#[repr(C)]
union MyUnion {
    f1: u32,
    f2: f32,
}

```
