## 配置生产模式

当 panic 发生时，程序会默认开始栈展开，在 Release 版本中，我们可能不希望程序在 panic 时进行栈展开，而是直接退出程序，此时我们可以通过配置 panic 展开模式来控制是否展开：

```toml
# Cargo.toml 配置文件

[profile.release]
# 配置 Release 模式下，panic 时直接退出程序，不执行Drop流程，如果使用了Drop，则不能开启这个配置，否则清理过程将不会执行
panic = "abort"
strip = "debuginfo"  # 移除调试符号
debug = "none" # 禁用调试信息

# 默认配置，配置 Debug 模式下，panic 时进行栈展开，不配置也可以，此项为默认配置
[profile.dev]
panic = "unwind"
```

下面的命令可以配置 Release 编译模式：

```rust
// 编译是否是 Release 模式，不影响panic是否展开，只影响符号表的生成
cargo build --release
```

如果不希望在 panic 时进行栈回溯输出，可以设置环境变量：RUST_BACKTRACE 为 0：

```rust
// 在main函数中，设置环境变量，不进行栈回溯输出
unsafe {
  std::env::set_var("RUST_BACKTRACE", "0");
}
```

## 基础的错误处理案例

```rust
use std::fs::File;
use std::io::{Error, ErrorKind};

pub fn run() {
    let fp = File::open("hello.txt");

    let fp = match fp {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(file) => file,
                Err(error) => panic!("create file failed: {:?}", error),
            },
            other_error => panic!("open file failed: {:?}", error),
        },
    };
}
```

### 将 Match 更换为快捷 API

```rust
use std::fs::File;
use std::io::{Error, ErrorKind};

pub fn run() {
    let fp = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("create file failed: {:?}", error);
            })
        } else {
            panic!("open file failed: {:?}", error);
        }
    });
}
```
