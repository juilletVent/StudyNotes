## 不太聪明的生命周期检查

编译器应用生命周期三原则自动补全生命周期参数时，有时候不太聪明，像下面的案例：

```rust
#[derive(Debug)]
struct Foo;

impl Foo {
    fn mutate_and_share(&mut self) -> &Self {
        &*self
    }
    fn share(&self) {}
}

fn main() {
    let mut foo = Foo;
    let loan = foo.mutate_and_share();
    foo.share();
    println!("{:?}", loan);
}
```

根据生命周期省略原则三，`mutate_and_share` 方法的返回值生命周期应该和 `self` 一致，因此`&mut self` 的生命周期将与`loan`的生命周期一样，持续到`main`函数结束。

这会导致`foo.share();` 的调用失败，因为它需要对`foo`进行不可变借用。

第二个例子：

```rust
#![allow(unused)]
fn main() {
    use std::collections::HashMap;
    use std::hash::Hash;
    fn get_default<'m, K, V>(map: &'m mut HashMap<K, V>, key: K) -> &'m mut V
    where
        K: Clone + Eq + Hash,
        V: Default,
    {
        // 此处，get_mut 会对map进行可变借用，并且，map的借用生命周期会持续到match语句结束，而不是调用结束
        match map.get_mut(&key) {
            Some(value) => value,
            None => {
                map.insert(key.clone(), V::default());
                map.get_mut(&key).unwrap()
            }
        }
    }
}
```

由于`get_mut` 对`map`的可变借用会持续到`match`语句结束，因此在 `match` 语句内将无法进行任何借用，实际上`get_mut`在调用结束时就应该释放对`map`的可变借用，然而实际上编译器推断不出来。

## 无界生命周期

```rust
fn f<'a, T>(x: *const T) -> &'a T {
    unsafe {
        &*x
    }
}
```

如何产生无界生命周期：当生命周期不来源于任何输入参数时，就会产生无界生命周期，像上面的函数生命一样（无界生命周期凭空产生）

## 生命周期约束 HRTB

生命周期约束跟特征约束类似，都是通过形如 'a: 'b 的语法，来说明两个生命周期的长短关系。

假设有两个引用 `&'a i32` 和 `&'b i32`，它们的生命周期分别是 `'a` 和 `'b`，若 `'a >= 'b`，则可以定义 `'a:'b`，表示 `'a` 至少要活得跟 `'b` 一样久。

```rust
struct DoubleRef<'a,'b:'a, T> {
    r: &'a T,
    s: &'b T // 这里，'b 至少要活得跟 'a 一样久
}
```

### 类型生命周期约束

T: 'a 表示类型 T 至少要活得跟 'a 一样久：

```rust
struct Ref<'a, T: 'a> {
    r: &'a T // 这里，T 至少要活得跟 'a 一样久，否则就是悬垂引用
}
```

在 Rust 1.30 版本之前，该写法是必须的，但是从 1.31 版本开始，编译器可以自动推导推导出上述生命周期约束。

## 闭包函数的消除规则

由于对闭包函数生命周期分析的复杂性，闭包函数无法像正常函数一样应用生命周期消除规则，外加闭包函数无法手动指定生命周期，进一步加剧了这个问题。

```rust
// 可以通过编译
fn fn_elision(x: &i32) -> &i32 {
    x
}

// 无法通过编译，未正确应用生命周期消除规则
let closure_slision = |x: &i32| -> &i32 { x };
```

对于上述问题，目前只能借助包装函数进行泛型生命周期推断

```rust
// 通过包装函数进行泛型生命周期推导，用 Fn 特征解决闭包生命周期问题
fn fun<T,F:(&T) -> F>(x: &i32) -> &i32 {
    x
}

#![allow(unused)]
fn main() {

    let closure_slision = fun(|x: &i32| -> &i32 { x });
    assert_eq!(*closure_slision(&45), 45);
    // Passed !
}
```

## NLL (Non-Lexical Lifetime)

Rust 1.31 版本之前，编译器对生命周期的分析是基于词法作用域的，这导致了一些问题，比如：

```rust
fn main() {
   let mut s = String::from("hello");

    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
    // 新编译器中，r1,r2作用域在这里结束，后续r3的借用检查将正常通过

    let r3 = &mut s;
    println!("{}", r3);
    // 在 1.31 版本之前，`r1` 和 `r2` 和 `r3` 的作用域都在这里结束，因此会导致借用检查失败
}
```

1.31 版本之前：**引用的生命周期从词法作用域开始，到词法作用域结束**。

1.31 版本引入 NLL 后：**引用的生命周期从借用处开始，一直持续到最后一次使用的地方**。

## 再借用 Reborrow

再借用允许我们通过已经创建的借用，再次创建另外一个借用，但是需要遵循一些原则：

- 再借用只能通过解引用-再借用的方式创建，
- 再借用会暂时"占用"原引用，原引用在再借用期间不可使用
- 借用检查规则同样起作用（可变一个，不可变多个）

```rust
fn main() {
    let mut original = String::from("hello");
    // 可变引用
    let reference_to_mut = &mut original;

    // 通过可变借用解引用再创建不可变借用（再借用）
    let reference_const = &*reference_to_mut;
    // 通过可变借用解引用再创建可变借用（再借用）
    let reference_const = &mut *reference_to_mut;
    // 错误：不可以直接使用原始变量直接创建不可变引用，不符合借用检查规则，再借用只能通过解引用-再借用的方式创建
    // let reference_const = &original;
    println!("{}", reference_const); // 在未使用原先的可变借用之前，再借用是合法的，可以保证了数据一致性
    // 再借用生命周期在此处结束

    // 使用原先的可变借用可以合法修改数据
    reference_to_mut.push_str(" world");
    println!("{}", reference_to_mut);
}
```

### 结构体再借用

对于结构体的再借用，可以整体借用，也可以部分借用：

```rust
struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn new(name: &str, age: u8) -> Self {
        Self {
            name: name.to_string(),
            age,
        }
    }
}

fn main() {
    let mut alice = Person::new("Alice", 24);
    let ref_alice = &mut alice;

    {
        // 再借用整体
        let rr = &mut *ref_alice;
        println!("{:?}", rr);
        // 再借用部分（自动解引用）
        let name = &mut ref_alice.name;
        *name = "Bob".to_string();

        // 误区：创建部分引用时，由于自动接引机制的存在，我们不需要再手动解引用了
        // 如果非要手动解引用，也需要注意运算符优先级：成员运算符的优先级高于解引用运算符
        // 因此下面的代码实际上被解释成：let name = (*(ref_alice.name));
        // 配合上自动解引用，最终代码为：let name = (*(*(ref_alice).name));
        // 很显然，这不是我们想要的

        // 错误写法
        // let name = *ref_alice.name;
        // 正确写法（显示解引用）
        let name = &mut (*ref_alice).name;
        *name = "Bob".to_string();
    }

    println!("{}", alice.name);
    println!("{}", alice.age);
}

```

## 生命周期消除规则补充

```rust
impl<'a> Reader for BufReader<'a> {
    // methods go here
    // impl内部实际上没有用到'a
}

// 可以改写成
impl Reader for BufReader<'_> {
    // methods go here
}
```

## 一个复杂的例子

没事儿的时候可以看看，有代表性：

```rust
struct Interface<'a> {
    manager: &'a mut Manager<'a>
}

impl<'a> Interface<'a> {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager<'a> {
    text: &'a str
}

struct List<'a> {
    manager: Manager<'a>,
}

impl<'a> List<'a> {
    pub fn get_interface(&'a mut self) -> Interface {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {
    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };

    list.get_interface().noop();

    println!("Interface should be dropped here and the borrow released");

    // 下面的调用会失败，因为同时有不可变/可变借用
    // 但是Interface在之前调用完成后就应该被释放了
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```

上述例子无法通过编译，需要修改为：

```rust
struct Interface<'b, 'a: 'b> {
    manager: &'b mut Manager<'a>
}

impl<'b, 'a: 'b> Interface<'b, 'a> {
    pub fn noop(self) {
        println!("interface consumed");
    }
}

struct Manager<'a> {
    text: &'a str
}

struct List<'a> {
    manager: Manager<'a>,
}

impl<'a> List<'a> {
    pub fn get_interface<'b>(&'b mut self) -> Interface<'b, 'a>
    where 'a: 'b {
        Interface {
            manager: &mut self.manager
        }
    }
}

fn main() {

    let mut list = List {
        manager: Manager {
            text: "hello"
        }
    };

    list.get_interface().noop();

    println!("Interface should be dropped here and the borrow released");

    // 下面的调用可以通过，因为Interface的生命周期不需要跟list一样长
    use_list(&list);
}

fn use_list(list: &List) {
    println!("{}", list.manager.text);
}
```

## `&'static` 与 `T: 'static`

- `&'static`：静态引用类型，阐明了当前引用指向的值在整个程序运行期间都存在
- `T: 'static`：**对 T 约束拥有所有权** 或者 **不包含非'static 生命周期的引用**

关键区别总结：

| 类型         | 基础类型          | 基础类型引用                                   |
| ------------ | ----------------- | ---------------------------------------------- |
| `T: 'static` | ✅ 基础类型都满足 | 基础类型的静态引用满足（字面量引用、常量引用） |
| `&'static T` | N/A 非引用类型    | 基础类型的静态引用满足（字面量引用、常量引用） |
