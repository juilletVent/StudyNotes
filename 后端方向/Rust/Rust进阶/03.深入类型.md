## As 转换

强制类型转换，在转换类型时，需要检查类型范围是否兼容，一个较小的类型转换到较大的类型，通常是安全的，反过来则是不安全的。

```rust
let a = 25i32;
let b = 15u8;

// 不安全
if a as u8 > b {
    println!("a > b");
}
// 安全
if a > b as i32 {
    println!("a > b");
}
```

另外一个强制类型转换的案例，经典指针操作：

```rust
let mut arr = [1, 2];
let p_arr = arr.as_mut_ptr();

unsafe {
    // 根据类型移动指针，参数含义是移动多少个这种类型的长度：i32 为 4字节，传入1则移动4个字节
    let second_addr = p_arr.add(2);
    // 纯手动计算偏移，容易出错
    // let second_addr = (p_arr as usize + 4) as *mut i32;
    *second_addr += 1;
}

println!("{arr:#?}"); // [1, 3]
```

### 转换传递性

考察下面的代码：

```rust
let a = 'c';
// 编译错误：字符类型不能转换到浮点型
// let val = a as f64;
// 编译成功：先转换为 i32，再转换为 f64
let val = a as i32 as f64;
println!("{val}");
```

虽然可以完成字符类型转换到浮点型的转换，切精度没有丢失，但是却没办法直接转换，这也就是不具备传递性的含义。

### 安全的强制转换

我们可以借助内置工具函数来进行不丢失精度的强制转换（小类型像大类型转换）：

```rust
fn main() {
    let b: i16 = 1500;

    let b_: u8 = match b.try_into() {
        Ok(b1) => b1,
        Err(e) => {
            println!("{:?}", e.to_string());
            0
        }
    };
}
```

`try_into` 将会捕获到大类型转换到小类型出现的精度丢失错误，然后返回一个 Result，我们借此来判断是否转换成功，而不是静默忽略溢出错误，除非你可以容忍溢出（溢出通常来说都是错误的）。

**Tips：强制类型转换以及`try_into` 都只能用于数值类型（底层是数值的也可以，比如 char、指针等），不可以用于其他类型。**

## 通用类型转换

### Trait 约束匹配不自动转型

在进行特征匹配检查时，实际参数不会进行自动强制类型转换（Trait 方法除外）

```rust
trait Trait {}

fn foo<X: Trait>(t: X) {}

impl<'a> Trait for &'a i32 {}

fn main() {
    let t: &mut i32 = &mut 0;
    foo(t); // 无法通过编译
    foo(t as &i32); // 可以通过编译
}
```

上述案例中，t 类型为 `&mut i32`, `foo` 的参数必须实现 `Trait` 特征，然后我们为 `&mut i32` 实现了 `Trait` 特征，因此只需要将 `&mut i32` 转换成 `&i32` 即可通过验证。

但是这个转换过程编译器不会自动执行。

### 点操作符

Rust 中点操作符的计算相当复杂，一点儿也不单纯，会发生很多魔法般的类型转换，例如：自动引用、自动解引用，强制类型转换直到类型能匹配等等。

假设类型 T，实现了方法 foo ,具备具备某一个接收器（self、&self、&mut self），如果调用 value.foo()，那么会发生什么？

1. 是否可以直接在值上进行调用：`value.foo()` 或者用完全限定语法 `T::foo(value)`
2. 前一步的匹配失败（进行特征匹配的时候不会进行自动强制类型转换），尝试进行引用调用：`(&value).foo()` 或者 `(&mut value).foo()`，用完全限定语法就是：`<&T>::foo(value)` 或者 `<&mut T>::foo(value)`
