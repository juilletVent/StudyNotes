## Pin 是什么

Rust 中很多类型在赋值移动时进行指针拷贝，这会导致内存地址变化，如果有自引用或其他形式的指针进行了地址引用，则会导致内存安全问题：

```rust
struct MoveStruct {
    name: String,
}

fn test_fn(a: MoveStruct) {
    println!("函数内 MoveStruct 地址: {:p}", &a);
    println!("函数内 String 地址: {:p}", &a.name);
    println!("函数内 字符串数据地址: {:p}", a.name.as_ptr());
}

fn main() {
    let aa = MoveStruct {
        name: "Alice".to_string(),
    };

    println!("main 中 MoveStruct 地址: {:p}", &aa);
    println!("main 中 String 地址: {:p}", &aa.name);
    println!("main 中 字符串数据地址: {:p}", aa.name.as_ptr());

    test_fn(aa);
}
```

上面的案例，在函数传参时，`MoveStruct` 被移动，导致 `String` 的地址发生变化，如果结构体存在对 String 的自引用，则会出现引用失效的致命问题，改用 Pin 之后就不会有问题了：

```rust
use std::pin::Pin;

struct MoveStruct {
    name: String,
}

fn test_fn(a: Pin<Box<MoveStruct>>) {
    println!("函数内 MoveStruct 地址: {:p}", &a);
    println!("函数内 String 地址: {:p}", &a.name);
    println!("函数内 字符串数据地址: {:p}", a.name.as_ptr());
}

fn main() {
    let aa = Box::pin(MoveStruct {
        name: "Alice".to_string(),
    });

    println!("main 中 MoveStruct 地址: {:p}", &aa);
    println!("main 中 String 地址: {:p}", &aa.name);
    println!("main 中 字符串数据地址: {:p}", aa.name.as_ptr());

    test_fn(aa);
}
```

## Pin<T>

智能指针，如果 T 类型没有实现 `Unpin` 特征，则 Pin 会阻止 T 类型被移动，否则编译器将允许进行移动：

```rust
use std::{pin::Pin};

let pinned: Pin<Box<i32>> = Box::pin(42);
let aa: Box<i32> = Pin::into_inner(pinned); // 由于 i32 实现了 Unpin 特征，所以可以进行移动，编译器不会阻止这个行为
```

对于没有实现 `Unpin` 特征的类型，编译器会报错：

```rust
use std::{marker::PhantomPinned, pin::Pin};

#[derive(Debug)]
struct MyUnpin {
    name: String,
    _pin: PhantomPinned, // Rust的魔术语法...用于标记当前结构体没有实现 Unpin Trait
}


let pinned: Pin<Box<MyUnpin>> = Box::pin(MyUnpin {
    name: "Alice".to_string(),
    _pin: PhantomPinned,
});
let aa: Box<MyUnpin> = Pin::into_inner(pinned); // 尝试将内部的Box移出，会被编译器阻止
```

## Unpin Trait

这是一个没有方法的标记特征（Mark Trait），表示类型可以安全的从 Pin 中被移出。默认的大部分数据类型都实现了这个 Trait。

如果一个自定义类型没有实现 `Unpin` 特征且包含的下属属性也都没实现 `Unpin` 特征，则默认情况下，编译器会认为该类型没有实现 `Unpin` 特征，此类型在哪怕在 Pin 包装内，依然可以被安全的移动。

如果希望为某个类型实现 `!Unpin` 特征，则需要使用 `PhantomPinned` 来标记该类型，表示该类型没有实现 `Unpin` 特征。

```rust
use std::{marker::PhantomPinned, pin::Pin};

#[derive(Debug)]
struct MyPinData {
    name: String,
    // 使用 PhantomPinned 来标记该类型没有实现 Unpin Trait，下划线开头可以消除未使用的编译警告
    // 属性名称不重要，重要是PhantomPinned类型，用于告知编译器，这个类型没有实现 Unpin Trait
    _pin: PhantomPinned,
}

let pinned: Pin<Box<MyPinData>> = Box::pin(MyPinData {
    name: "Alice".to_string(),
    _pin: PhantomPinned,
});
let aa: Box<MyPinData> = Pin::into_inner(pinned); // 尝试将内部的Box移出，会被编译器阻止
```

## !Unpin

表示没有实现 `Unpin` 特征，可以用于自定义类型，用于告知编译器，这个类型没有实现 `Unpin` 特征，这个类型不可以被移动，就像上面的 `MyPinData` 类型一样。

Tips：Rust 目前暂时没有支持负向 Trait 约束，`!Unpin` 只是告诉我们，该类型没有实现 `Unpin` 特征，我们无法为我们的类型约束添加类似 `!Unpin` 或者其他 `!Type`的 Trait 约束：

```rust
trait MyTrait {}

// 错误：不支持负向 Trait 约束
// error: negative bounds are not supported
fn run<T: Display + ?Sized + !MyTrait>(a: &T) {
    println!("{}", a);
}
```
