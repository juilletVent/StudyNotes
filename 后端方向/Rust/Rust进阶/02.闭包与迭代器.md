## FnOnce + Copy

我们知道 `Fn` Trait 同时实现了 `Copy` Trait，当我们的闭包需要捕获外部变量时，就会出现所有权转移，而如果捕获的值实现了`Copy` Trait，则会出现值复制，最终闭包类型是 `Fn`。

而 `FnOnce` 并未实现 `Copy` Trait，如果我们希望`FnOnce` 类型的闭包可以调用多次，则可以使用`FnOnce + Copy` 约束，这样的约束可以使得接受的闭包类型在类型层面更加宽泛，而闭包体逻辑是等价的。

总结：`FnOnce + Copy` 在行为上与 `Fn` 完全等价，只是在 API 语义上凸显出这个闭包是一个仅应该调用一次且无副作用的闭包。

事实上，我们无法构建出满足 `FnOnce + Copy` 约束，但是不满足 `Fn` 约束的闭包。

## FnMut 与 变量 mut

```rust
fn main() {
    let mut s = String::new();
    // 闭包并未声明 mut
    let update_string =  |str| s.push_str(str);

    // update_string("114514") // 这会导致报错，因为闭包缺少 mut 声明

    // 闭包满足 FnMut 约束，可以调用
    exec(update_string);

    println!("{:?}",s);
}

fn exec<'a, F: FnMut(&'a str)>(mut f: F)  {
    f("hello")
}
```

FnMut 是类型约束，变量 mut 是变量可变性声明，两者没有关系。看下面的另外一个例子，应该会更好理解：

```rust
fn main() {
    let a = String::from("Hello");

    // a.push_str("World"); // 这会导致报错，因为 a 是不可变变量

    // 满足类型约束，可以调用
    test_mut(a);
}

fn test_mut(mut a: String) {
    a.push_str(" World");
    println!("a: {a}")
}
```

### 闭包引用

一个更复杂一点的传递闭包引用：

```rust
fn main() {
    let mut s = String::new();

    // FnMut 闭包
    let mut update_string = |str| s.push_str(str);

    // 传递闭包引用，并进行多次调用
    exec(&mut update_string);
    exec(&mut update_string);

    println!("{:?}", s);
}

//
fn exec<'a, F: FnMut(&'a str)>(f: &mut F) {
    f("hello111");
    f("hello111");
}

```

## 返回闭包

小案例：

```rust
fn main() {
    let f = factory(6);

    println!("{}", f(10));
    println!("{}", f(11));
}

// 错误：Fn(i32) -> i32 是 Trait 约束，并不是具体的类型，因此无法作为返回类型使用
// fn factory(n: i32) -> Fn(i32) -> i32 {
// 错误：对于返回类型来说，由于加上了 impl ，含义变成了：实现了 Fn(i32) -> i32 特征的任意闭包类型，对于单个闭包来说，这没问题
// 但是对于存在多分支，返回满足同一个约束的，但是类型不同的闭包时，仍然会出现错误
// fn factory(n: i32) -> impl Fn(i32) -> i32 {
// 正确：最终方案，使用特征对象进行包装返回
fn factory(n: i32) -> Box<dyn Fn(i32) -> i32> {
    let num = 5;

    // 直接返回闭包
    // if n > 5 { |x| x + num } else { |x| x - num }

    // 使用特征对象返回签名相同的不同闭包
    if n > 5 {
        Box::new(move |x| x + num)
    } else {
        Box::new(move |x| x - num)
    }
}
```

## 迭代器

### 不同迭代器用法的对比

```rust
// 这三种情况的内存语义：
let vec = vec![1, 2, 3];

// 1. 消费：vec 被移动
for item in vec { ... }
// vec 在这里已经不可用

// 2. 借用：vec 保持可用
for item in &vec { ... }
// vec 在这里仍然可用

// 3. 可变借用：vec 保持可用但内容可能改变
for item in &mut vec { ... }
// vec 在这里仍然可用
```

如果要为自定义类型创建对应的迭代器的话，需要分写对应不同的类型实现 `IntoIterator Trait`:

```rust
// 直接迭代，应该返回消费迭代器
impl<T> IntoIterator for Vec<T> {
    fn into_iter(self) -> IntoIter<T> { ... }
}
// 借用迭代，应该返回借用迭代器
impl<'a, T> IntoIterator for &'a Vec<T> {
    fn into_iter(self) -> Iter<'a, T> { ... }
}
// 可变借用迭代，应该返回可变借用迭代器
impl<'a, T> IntoIterator for &'a mut Vec<T> {
    fn into_iter(self) -> IterMut<'a, T> { ... }
}
```

通过下面的小例子可以观察到不同迭代器的类型：

```rust
fn main() {
    let mut arr = vec![1, 2, 3];

    let mut_iter: std::slice::IterMut<'_, i32> = arr.iter_mut(); // 可变借用迭代器
    let iter: std::slice::Iter<'_, i32> = arr.iter(); // 借用迭代器
    let iter2: std::slice::Iter<'_, i32> = arr.iter(); // 借用迭代器
    println!("{arr:#?}");
    let into_iter: std::vec::IntoIter<i32> = arr.into_iter(); // 消费迭代器
}
```

### 创建自定义迭代器（消耗迭代器、借用迭代器、可变借用迭代器）

根据上面对应的三种迭代器，我们可以为自定义类型分别实现三种迭代器特性：

```rust
// TODO 有点儿难...写好了再补上来
```
