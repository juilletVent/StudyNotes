## Cell 的不同内存模型

Cell 包装类型有两种用法，第一种使用值创建包装：

```rust
let mut original = 123;
let cell_box = Cell::new(original);
cell_box.set(114514);
println!("{original}"); // 123
println!("{}", cell_box.get()); // 114514
```

可以观察到，原始值未发生变化，因为 Cell 的包装目标必须实现了 Copy Trait，直接传递值的话，就会进行值 Copy，这也就以为这，Cell 与原始值互不干涉，不共享内存空间。

第二种，使用引用创建包装对象：

```rust
let mut original = 123;
// 传入可变借用
let cell_box = Cell::from_mut(&mut original);
// 原地修改
cell_box.set(114514);
println!("{original}"); // 114514
```

可以观察到，原始值发生了变化，由于使用 `Cell::from_mut` 创建包装对象，Cell 与原始值共享同一片内存空间，修改就变成了原地修改，会影响原值。

## 通过 Cell::from_mut 解决借用冲突

在 Rust 1.37 版本中新增了两个非常实用的方法：

- Cell::from_mut: 该方法将 `&mut T` 转为 `&Cell<T>`，创建的 Cell 与引用原始值共享同一片内存
- Cell::as_slice_of_cells: 该方法将 `&Cell<[T]>` 转为 `&[Cell<T>]`

上面的方法对于下面案例出现的借用冲突非常有用：

```rust
fn is_even(i: i32) -> bool {
    i % 2 == 0
}

fn retain_even(nums: &mut Vec<i32>) {
    let mut i = 0;
    // nums.iter() 创建迭代器，这会儿对nums进行不可变借用
    for num in nums.iter().filter(|&num| is_even(*num)) {
        // 编译错误：cannot borrow `*nums` as mutable because it is also borrowed as immutable
        // 此处进行赋值，会尝试对nums进行可变借用，违反了借用规则
        nums[i] = *num;
        i += 1;
    }
    nums.truncate(i);
}
```

这种过滤需求是相当常见的需求，有了上述的 API，我们可以通过下面的方法，利用 Cell 内部可变性来完成这个需求：

```rust
fn retain_even(nums: &mut Vec<i32>) {
    // 创建原Vec的切片，并将切片转换为Cell包装对象：将 &mut [i32] 转为 &Cell<[i32]>
    // 因为as_slice_of_cells定义在Cell<[T]>上，所以需要将 &mut [i32] 转为 &Cell<[i32]>
    let cells: &Cell<[i32]> = Cell::from_mut(&mut nums[..]);
    // 将 &Cell<[i32]> 转为 &[Cell<i32>]
    // Cell包装的一个[i32]切片，转换为了一个Cell<i32>的切片
    let slice: &[Cell<i32>] = cells.as_slice_of_cells();
    // 创建迭代器
    let iter: std::slice::Iter<'_, Cell<i32>> = slice.iter();
    // 过滤，注意：迭代器产出的是 T类型，过滤器接收的是 &T类型（因为Filter并不需要过滤值的所有权）
    // 因此，闭包参数使用 &num 或者 num 都行，类型推断分别是 &Cell<i32> 和 &&Cell<i32>
    // 至于调用get方法，由于Cell实现了Deref<Target = T>，所以不论 &Cell<i32> 还是 &&Cell<i32>，都可以直接调用get方法
    let filter_iter = iter.filter(|&num| is_even(num.get()));

    let mut i: usize = 0;
    // 遍历过滤后的迭代器
    for num in filter_iter {
        // 修改 Cell 的值
        slice[i].set(num.get());
        i += 1;
    }

    // 截取
    nums.truncate(i);
}

// 实际使用中，可以简化为下面的写法
fn retain_even(nums: &mut Vec<i32>) {
    let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..])
        .as_slice_of_cells();

    let mut i = 0;
    for num in slice.iter().filter(|num| is_even(num.get())) {
        slice[i].set(num.get());
        i += 1;
    }

    nums.truncate(i);
}
```
