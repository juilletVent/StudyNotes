## 线程流程同步机制（线程屏障）

线程屏障（Barrier）允许多个线程在某个点上进行同步等待，等待所有线程都执行的某个位置后再一起继续执行后续流程：

```rust
use std::sync::{Arc, Barrier};
use std::thread;
fn main() {
    let mut handles = Vec::with_capacity(6);
    // 创建一个线程屏障，等待 6 个线程，使用Arc进行共享
    let barrier = Arc::new(Barrier::new(6));

    for _ in 0..6 {
        // 克隆屏障的引用
        let wait_point = barrier.clone();
        handles.push(thread::spawn(move || {
            println!("before");
            // 等待所有线程到达屏障点
            wait_point.wait();
            println!("after");
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

## 线程锁（Mutex）

Rust 中线程同步锁与 Condvar 一同使用，Mutex 用于保护共享数据，Condvar 用于线程间的通知和等待机制。

```rust
use std::thread;
use std::sync::{Arc, Mutex, Condvar};

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    thread::spawn(move|| {
        let (lock, cvar) = &*pair2;
        let mut started = lock.lock().unwrap(); // 子线程获取锁
        println!("changing started");
        *started = true; // 修改共享数据
        cvar.notify_one(); // 通知等待的线程，数据已经变化，可以继续执行了
    });

    let (lock, cvar) = &*pair;
    let mut started: std::sync::MutexGuard<'_, bool> = lock.lock().unwrap(); // 主线程获取锁
    while !*started { // 检查共享数据是否已被修改，是否满足条件，如果没有满足条件，则继续等待
        // 阻塞：等待通知，cvar.wait 会消耗传入的锁并释放
        // 如果得到通知，则会重新获取锁（返回一个MutexGuard），此时started就可以继续判定值是否变化了
        // 如果仍未满足条件，将继续等待，并再次释放锁，直到条件满足，非常巧妙的设计
        started = cvar.wait(started).unwrap();
    }

    println!("started changed");
}
```

一个字妙啊，难怪 MutexGuard 没有 unlock 方法，因为它在离开作用域时会自动释放锁，从根本上避免了忘记释放的问题。

## 仅执行一次的 Once、OnceLock

多线程之间可能会共享某些全局数据，这些数据只需要初始化一次，一般来说交给主线程/启动线程进行预初始化是最好的，但是有时候初始化这个动作是昂贵的，或者依赖余子线程执行时的某些检查或运行时，无法剥离出来单独执行，这时候就需要使用 Once 来确保只执行一次。

```rust
use std::sync::Once;

// 共享的全局数据
static mut EXPENSIVE_RESOURCE: Option<Vec<u8>> = None;
// Once 用于确保只执行一次的初始化
static INIT: Once = Once::new();

// init函数可以在任何线程中调用，但初始化逻辑只会执行一次
fn init() -> &'static Vec<u8> {
    INIT.call_once(|| unsafe {
        // 只有在真正需要时才执行昂贵的初始化
        EXPENSIVE_RESOURCE = Some(vec![0; 1_000_000]);
    });
    // 返回全局配置引用
    unsafe { EXPENSIVE_RESOURCE.as_ref().unwrap() }
}

// OnceLock 更加现代化，无需unsafe
static INIT_SAFE: OnceLock<usize> = OnceLock::new();
fn init() -> &'static usize {
    INIT_SAFE.get_or_init(|| 114514)
}
```
