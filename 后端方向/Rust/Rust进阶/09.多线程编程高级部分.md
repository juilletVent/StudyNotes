## 线程流程同步机制（线程屏障）

线程屏障（Barrier）允许多个线程在某个点上进行同步等待，等待所有线程都执行的某个位置后再一起继续执行后续流程：

```rust
use std::sync::{Arc, Barrier};
use std::thread;
fn main() {
    let mut handles = Vec::with_capacity(6);
    // 创建一个线程屏障，等待 6 个线程，使用Arc进行共享
    let barrier = Arc::new(Barrier::new(6));

    for _ in 0..6 {
        // 克隆屏障的引用
        let wait_point = barrier.clone();
        handles.push(thread::spawn(move || {
            println!("before");
            // 等待所有线程到达屏障点
            wait_point.wait();
            println!("after");
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```

## 线程间的控制，挂起与唤醒（Mutex、Condvar）

Rust 中线程同步锁与 Condvar 一同使用，Mutex 用于保护共享数据，Condvar 用于线程间的通知和等待机制。

```rust
use std::thread;
use std::sync::{Arc, Mutex, Condvar};

fn main() {
    let pair = Arc::new((Mutex::new(false), Condvar::new()));
    let pair2 = pair.clone();

    thread::spawn(move|| {
        let (lock, cvar) = &*pair2;
        let mut started = lock.lock().unwrap(); // 子线程获取锁
        println!("changing started");
        *started = true; // 修改共享数据
        cvar.notify_one(); // 通知等待的线程，数据已经变化，可以继续执行了
    });

    let (lock, cvar) = &*pair;
    let mut started: std::sync::MutexGuard<'_, bool> = lock.lock().unwrap(); // 主线程获取锁
    while !*started { // 检查共享数据是否已被修改，是否满足条件，如果没有满足条件，则继续等待
        // 阻塞：等待通知，cvar.wait 会消耗传入的锁并释放
        // 如果得到通知，则会重新获取锁（返回一个MutexGuard），此时started就可以继续判定值是否变化了
        // 如果仍未满足条件，将继续等待，并再次释放锁，直到条件满足，非常巧妙的设计
        started = cvar.wait(started).unwrap();
    }

    println!("started changed");
}
```

一个字妙啊，难怪 MutexGuard 没有 unlock 方法，因为它在离开作用域时会自动释放锁，从根本上避免了忘记释放的问题。

## 仅执行一次的 Once、OnceLock

多线程之间可能会共享某些全局数据，这些数据只需要初始化一次，一般来说交给主线程/启动线程进行预初始化是最好的，但是有时候初始化这个动作是昂贵的，或者依赖余子线程执行时的某些检查或运行时，无法剥离出来单独执行，这时候就需要使用 Once 来确保只执行一次。

```rust
use std::sync::Once;

// 共享的全局数据
static mut EXPENSIVE_RESOURCE: Option<Vec<u8>> = None;
// Once 用于确保只执行一次的初始化
static INIT: Once = Once::new();

// init函数可以在任何线程中调用，但初始化逻辑只会执行一次
fn init() -> &'static Vec<u8> {
    INIT.call_once(|| unsafe {
        // 只有在真正需要时才执行昂贵的初始化
        EXPENSIVE_RESOURCE = Some(vec![0; 1_000_000]);
    });
    // 返回全局配置引用
    unsafe { EXPENSIVE_RESOURCE.as_ref().unwrap() }
}

// OnceLock 更加现代化，无需unsafe
static INIT_SAFE: OnceLock<usize> = OnceLock::new();
fn init() -> &'static usize {
    INIT_SAFE.get_or_init(|| 114514)
}
```

## Atomic 原子类型

Atomic 提供无锁并发编程，仅提供对数值类型的原子操作，下面是一个简单的例子：

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

// 创建全局共享的原子计数器
static COUNTER: AtomicUsize = AtomicUsize::new(0);

fn main() {
    // 直接修改计数器的值，第二参数是指定所使用的内存顺序，后面会讲解
    COUNTER.store(2, Ordering::Relaxed);
    // 计数器的值操作
    COUNTER.fetch_add(1, Ordering::Relaxed);
    COUNTER.fetch_sub(1, Ordering::Relaxed);
    COUNTER.fetch_and(1, Ordering::Relaxed);
    COUNTER.fetch_or(1, Ordering::Relaxed);
    COUNTER.fetch_xor(1, Ordering::Relaxed);
    // 获取当前计数器的值，传入的参数同样是内存模型，用于内存屏障建立
    let current_value = COUNTER.load(Ordering::Relaxed);

    // 替换计数器的值，返回旧值
    let old_value = COUNTER.swap(10, Ordering::Relaxed);
    println!("旧值: {}", old_value);
    // 比较与替换，如果比较成功，则替换，并返回旧的值
    let old_value = COUNTER.compare_exchange(10, 100, Ordering::Relaxed, Ordering::Relaxed);
    println!("旧值: {:?}", old_value);

    println!("当前计数器的值: {}", current_value);
}

```

### 内存顺序如何影响多线程编程并导致错误

```rust
use std::thread;
use std::sync::atomic::{AtomicBool, Ordering};

static FLAG: AtomicBool = AtomicBool::new(false);
static mut DATA: i32 = 0;

fn main() {
    thread::spawn(|| {
        unsafe { DATA = 42; }
        FLAG.store(true, Ordering::Relaxed); // 没有 Release
    });

    thread::spawn(|| {
        while !FLAG.load(Ordering::Relaxed) {} // 没有 Acquire
        println!("{}", unsafe { DATA }); // 可能打印 0 !
    }).join().unwrap();
}
```

由于没有使用任何内存顺序限制建立内存屏障，导致虽然 FLAG 的读取与写入没有问题，但是与至相关的数据 DATA 的写入与读取是没有任何保护的，编译器优化可能会移动指令位置，比如将实际代码可能会变成下面的样子：

```rust
fn main() {
    thread::spawn(|| {
        FLAG.store(true, Ordering::Relaxed);
        unsafe { DATA = 42; }
    });

    thread::spawn(|| {
        while !FLAG.load(Ordering::Relaxed) {} // 没有 Acquire
        println!("{}", unsafe { DATA }); // 可能打印 0 !
    }).join().unwrap();
}
```

按照我们本来的逻辑，当 FLAG 被设置为 true 时，DATA 的写入操作应该已经完成，但是编译器优化后，DATA 的写入操作可能被移动到 FLAG 的写入操作之后，导致另外的线程判定到 FLAG 为 true，但是取得的 DATA 仍就是旧值。

原子类型的读写操作 API 中传入的内存顺序就是用来控制这个行为的，防止出现上述的问题。

### 与内存顺序的关系

内存顺序（Memory Ordering）是原子操作中的一个重要概念，它定义了多线程环境下对共享变量的访问顺序，操作系统定义了下面几种内存顺序：

- Relaxed：宽松顺序，不保证原子操作的顺序，只保证原子操作的可见性
- Release：释放顺序，Release 操作之 **前** 的所有写入/读操作 **不能跑到它后面**；原子操作之后的操作可能重排的前面。
- Acquire：获取顺序，Acquire 操作之 **后** 的所有读/写操作 **不能跑到它前面**；原子操作之前的操作可能重排的后面的。
- AcqRel：Acquire-Release 顺序，Acquire 和 Release 的结合，原子操作点前后的指令均不能重排到它前面或后面。
- SeqCst：顺序一致性，相当于 Acquire-Release 顺序，但是更严格，所有操作都按顺序执行。

_Tips: 如果只是单纯的需要保证共享数据的原子操作安全性，则使用 Relaxed 即可，如果需要保证原子操作节点前后的逻辑，则需要考虑使用其他内存顺序，一般来说用的比较少，逻辑更多的可能使用 Mutex 来控制，毕竟更多的场合是使用复杂数据结构而不是简单的数值类型。_

### API 速查表

通用辅助函数速查表

| 方法                                                   | 作用                                   | 返回值                 | 适用范围     |
| ------------------------------------------------------ | -------------------------------------- | ---------------------- | ------------ |
| **`new(val)`**                                         | 创建原子变量                           | 新的原子实例           | 所有原子类型 |
| **`load(order)`**                                      | 读取值                                 | 当前值                 | 所有         |
| **`store(val, order)`**                                | 写入值                                 | `()`                   | 所有         |
| **`swap(val, order)`**                                 | 设置新值，返回旧值                     | 旧值                   | 所有         |
| **`compare_exchange(current, new, success, failure)`** | CAS：当前值等于 `current` 时设为 `new` | `Result<旧值, 实际值>` | 所有         |
| **`compare_exchange_weak(...)`**                       | 与上类似，但可能虚假失败，需要循环     | 同上                   | 所有         |
| **`get_mut()`**                                        | 获取可变引用（无并发时）               | `&mut T`               | 所有         |
| **`into_inner()`**                                     | 消费自身，取内部值                     | `T`                    | 所有         |

整数原子类型特有方法（AtomicIxx、AtomicUxx）：

| 方法                                    | 作用                                    | 返回值                 |
| --------------------------------------- | --------------------------------------- | ---------------------- |
| **`fetch_add(val, order)`**             | 原子加 `val`                            | 旧值                   |
| **`fetch_sub(val, order)`**             | 原子减 `val`                            | 旧值                   |
| **`fetch_and(val, order)`**             | 原子按位与                              | 旧值                   |
| **`fetch_or(val, order)`**              | 原子按位或                              | 旧值                   |
| **`fetch_xor(val, order)`**             | 原子按位异或                            | 旧值                   |
| **`fetch_update(success, failure, f)`** | 用闭包 `f(old) -> Option(new)` 计算更新 | `Result<旧值, 实际值>` |
