## 枚举与整数

Rust 中，枚举转换成整形比较简单，直接强制转换即可：

```rust
enum ConnectState {
    Disconnected = 0,
    Connecting,
    Connected,
}

let link_state = ConnectState::Connecting;
let link_state_i32 = link_state as i32;
```

但是想少反向转换回来可就要命令：

```rust
let link_state_i32 = 2;
// 编译错误
let link_state = link_state_i32 as ConnectState;
```

至于为什么这么费劲，是因为在 Rust 中，存储枚举的内存类型并不是一个固定的类型，编译器会根据枚举值选择一个尽可能小的内存类型来存放枚举，这也就导致不允许整数转换到枚举类型（因为内存模型都可能不一样，强制进行映射是未定义的行为，相当于大类型转换到小类型，会出现溢出，或者因为字节序不一致而出现问题）

虽然强制类型转换不行，但是还是可以进行转换的。

### 使用第三方库

- num-traits：Trait 引入
- num-derive：属性宏引入

另外一个比较新的库：`num_enums`

```rust
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;

#[derive(FromPrimitive)]
enum MyEnum {
    A = 1,
    B,
    C,
}

fn main() {
    let x = 2;
    match FromPrimitive::from_i32(x) {
        Some(MyEnum::A) => println!("Got A"),
        Some(MyEnum::B) => println!("Got B"),
        Some(MyEnum::C) => println!("Got C"),
        None            => println!("Couldn't convert {}", x),
    }
}
```

### 使用 TryFrom + 宏 (Rust 1.34 后)

```rust
use std::convert::TryFrom;

// 为枚举实现 TryFrom<i32> trait
impl TryFrom<i32> for MyEnum {
    type Error = ();

    fn try_from(v: i32) -> Result<Self, Self::Error> {
        match v {
            x if x == MyEnum::A as i32 => Ok(MyEnum::A),
            x if x == MyEnum::B as i32 => Ok(MyEnum::B),
            x if x == MyEnum::C as i32 => Ok(MyEnum::C),
            _ => Err(()),
        }
    }
}


// main.rs 使用定义的转换
use std::convert::TryInto;
fn main() {
    let x = MyEnum::C as i32;

    match x.try_into() {
        Ok(MyEnum::A) => println!("a"),
        Ok(MyEnum::B) => println!("b"),
        Ok(MyEnum::C) => println!("c"),
        Err(_) => eprintln!("unknown number"),
    }
}
```

上面的代码在每次添加新枚举时，转换工具函数也需要修改，比较麻烦，可以使用下面的宏来进行优化：

```rust
#[macro_export]
macro_rules! back_to_enum {
    ($(#[$meta:meta])* $vis:vis enum $name:ident {
        $($(#[$vmeta:meta])* $vname:ident $(= $val:expr)?,)*
    }) => {
        $(#[$meta])*
        $vis enum $name {
            $($(#[$vmeta])* $vname $(= $val)?,)*
        }

        impl std::convert::TryFrom<i32> for $name {
            type Error = ();

            fn try_from(v: i32) -> Result<Self, Self::Error> {
                match v {
                    $(x if x == $name::$vname as i32 => Ok($name::$vname),)*
                    _ => Err(()),
                }
            }
        }
    }
}

// 为枚举添加类型转换能力
back_to_enum! {
    enum MyEnum {
        A = 1,
        B,
        C,
    }
}
```

使用宏包裹枚举定义后，再添加新的枚举时就不需要再编写对应的转换规则了，使用 match 转换时也与上面之前的用法一致。

### 骚东西（std::mem::transmute）

先前提到过，如果你能确保内存模型完全一致，则可以剑走偏锋，使用 `std::mem::transmute` 来进行转换。

```rust
// 这一行非常重要，因为它确保了枚举的内存布局使用 i32
#[repr(i32)]
enum MyEnum {
    A = 1, B, C
}

fn main() {
    let x = MyEnum::C;
    let y = x as i32;
    // 使用类型变形，直接转换i32到枚举
    let z: MyEnum = unsafe { std::mem::transmute(y) };

    match z {
        MyEnum::A => { println!("Found A"); }
        MyEnum::B => { println!("Found B"); }
        MyEnum::C => { println!("Found C"); }
    }
}
```

重点：能够像上面这样用，有一个非常重要的前提：必须保证枚举的内存布局与 i32 完全一致，或者说枚举的内存布局与强制转换的来源类型完全一致。

这也是为什么我们需要使用`#[repr(i32)]`为枚举指定内存布局的原因。因为编译器在默认情况下会根据定义的枚举值大小确定一个最小的合适数值类型来存储枚举值，如果我们定义的枚举值比较小，编译器很可能使用 `u8`、`u16` 等类型来存储枚举值，此时两种类型的内存大小都不一样，如果直接使用类型变形，后果可想而知。
