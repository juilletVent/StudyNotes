## 常量

```rust
const MAX_ID: usize =  usize::MAX / 2;
```

- const 声明，全大写
- 初始化值必须编译期间可以求值，不能动态初始化
- 运行时不保证内存地址唯一性，编译器可能会进行值内嵌，导致出现多个相同的常量拷贝

## 全局变量

```rust
static mut REQUEST_RECV: usize = 0;
```

- static 声明，全大写
- 初始化值必须编译期间可以求值，不能动态初始化
- 运行时保证内存地址唯一性，编译器不会进行值内嵌，单例
- 需要使用 unsafe 来访问（如果全局变量使用的是原子类型，则不需要）
- 存储在静态变量中的值必须要实现 Sync trait，否则无法被多个线程共享

## 运行期初始化

对于需要执行来进行初始化的全局变量：

```rust
// 报错，全局静态变量不能使用动态初始化
static NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));
```

此时可以使用社区提供的 lazy_static 宏来实现：

```rust
use std::sync::Mutex;
use lazy_static::lazy_static;
lazy_static! {
    static ref NAMES: Mutex<String> = Mutex::new(String::from("Sunface, Jack, Allen"));
}
```

lazy_static 直到运行到 main 中的第一行代码时，才进行初始化。

### 使用 Box::leak 实现延迟初始化

下面的常规实现是不行的：

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}
static mut CONFIG: Option<&mut Config> = None;

fn main() {
    unsafe {
        // 尝试使用匿名的局部变量为全局变量赋值，局部变量的声明周期不够长，无法为全局静态变量赋值
        CONFIG = Some(&mut Config {
            a: "A".to_string(),
            b: "B".to_string(),
        });

        println!("{:?}", CONFIG)
    }
}
```

使用 Box::leak 将局部变量转换为全局变量（主动泄漏）：

```rust
#[derive(Debug)]
struct Config {
    a: String,
    b: String
}
static mut CONFIG: Option<&mut Config> = None;

fn main() {
    let c = Box::new(Config {
        a: "A".to_string(),
        b: "B".to_string(),
    });

    unsafe {
        // 将`c`从内存中泄漏，变成`'static`生命周期
        CONFIG = Some(Box::leak(c));
        println!("{:?}", CONFIG);
    }
}
```

一个更加安全的实现，带有多次赋值时先前泄漏的配置回收：

```rust
use std::mem;

#[derive(Debug)]
struct Config {
    a: String,
    b: String,
}

static mut CONFIG: Option<&'static mut Config> = None;

fn set_config(new: Config) {
    unsafe {
        // 如果已有配置，把它转回 Box 并 drop 掉
        if let Some(old_ref) = CONFIG.take() {
            // 关键：从引用恢复 Box
            let old_box: Box<Config> = Box::from_raw(old_ref as *mut Config);
            drop(old_box); // 显式回收
        }

        // 新配置转成 &'static mut
        CONFIG = Some(Box::leak(Box::new(new)));
    }
}

fn main() {
    set_config(Config {
        a: "A".to_string(),
        b: "B".to_string(),
    });

    unsafe {
        println!("{:?}", CONFIG);
    }

    set_config(Config {
        a: "X".to_string(),
        b: "Y".to_string(),
    });

    unsafe {
        println!("{:?}", CONFIG);
    }
}

```
