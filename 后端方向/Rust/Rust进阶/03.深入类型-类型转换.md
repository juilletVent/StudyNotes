## As 转换

强制类型转换，在转换类型时，需要检查类型范围是否兼容，一个较小的类型转换到较大的类型，通常是安全的，反过来则是不安全的。

```rust
let a = 25i32;
let b = 15u8;

// 不安全
if a as u8 > b {
    println!("a > b");
}
// 安全
if a > b as i32 {
    println!("a > b");
}
```

另外一个强制类型转换的案例，经典指针操作：

```rust
let mut arr = [1, 2];
let p_arr = arr.as_mut_ptr();

unsafe {
    // 根据类型移动指针，参数含义是移动多少个这种类型的长度：i32 为 4字节，传入1则移动4个字节
    let second_addr = p_arr.add(2);
    // 纯手动计算偏移，容易出错
    // let second_addr = (p_arr as usize + 4) as *mut i32;
    *second_addr += 1;
}

println!("{arr:#?}"); // [1, 3]
```

### 转换传递性

考察下面的代码：

```rust
let a = 'c';
// 编译错误：字符类型不能转换到浮点型
// let val = a as f64;
// 编译成功：先转换为 i32，再转换为 f64
let val = a as i32 as f64;
println!("{val}");
```

虽然可以完成字符类型转换到浮点型的转换，切精度没有丢失，但是却没办法直接转换，这也就是不具备传递性的含义。

### 安全的强制转换

我们可以借助内置工具函数来进行不丢失精度的强制转换（小类型像大类型转换）：

```rust
fn main() {
    let b: i16 = 1500;

    let b_: u8 = match b.try_into() {
        Ok(b1) => b1,
        Err(e) => {
            println!("{:?}", e.to_string());
            0
        }
    };
}
```

`try_into` 将会捕获到大类型转换到小类型出现的精度丢失错误，然后返回一个 Result，我们借此来判断是否转换成功，而不是静默忽略溢出错误，除非你可以容忍溢出（溢出通常来说都是错误的）。

**Tips：强制类型转换以及`try_into` 都只能用于数值类型（底层是数值的也可以，比如 char、指针等），不可以用于其他类型。**

try_into 默认是基于你的赋值情况自动推断转换的目标类型，如果你不提供，则无法确定目标类型，如果你不想提供，可以直接使用完全限定语法明确指定目标类型：

```rust
let val = 1i32;
match TryInto::<u32>::try_into(val) {
    Ok(v) => println!("{v}"),
    Err(_) => println!("error"),
}
```

## 通用类型转换

### Trait 约束匹配不自动转型

在进行特征匹配检查时，实际参数不会进行自动强制类型转换（Trait 方法除外）

```rust
trait Trait {}

fn foo<X: Trait>(t: X) {}

impl<'a> Trait for &'a i32 {}

fn main() {
    let t: &mut i32 = &mut 0;
    foo(t); // 无法通过编译
    foo(t as &i32); // 可以通过编译
}
```

上述案例中，t 类型为 `&mut i32`, `foo` 的参数必须实现 `Trait` 特征，然后我们为 `&mut i32` 实现了 `Trait` 特征，因此只需要将 `&mut i32` 转换成 `&i32` 即可通过验证。

但是这个转换过程编译器不会自动执行。

### 点操作符

Rust 中点操作符的计算相当复杂，一点儿也不单纯，会发生很多魔法般的类型转换，例如：自动引用、自动解引用，强制类型转换直到类型能匹配等等。

假设类型 T，实现了方法 foo ,具备某一个接收器（self、&self、&mut self），如果调用 value.foo()，那么会发生什么？

1. 是否可以直接在值上进行调用：`value.foo()` 或者用完全限定语法 `T::foo(value)`。
2. 前一步如果匹配失败（进行特征匹配的时候不会进行自动强制类型转换），尝试进行引用调用：`(&value).foo()` 或者 `(&mut value).foo()`，用完全限定语法就是：`<T>::foo(&value)` 或者 `<T>::foo(&mut value)`。
3. 如果前两步都失败了，将尝试进行解引用：`(*value).foo()`，如果解引用成功了，则将解引用取得的值再次从头应用规则进行匹配：

   假设 `Deref` 后得到的类型是 `&InnerType`，一般都是引用，如果直接是值的话，会出现值移动:

   1. `<InnerType>::foo(value);` 失败
   2. `<InnerType>::foo(&value);` 成功
   3. `<InnerType>::foo(&mut value);` 已经成功，不执行

4. 如果解引用失败，则会进行定长到不定长类型转换：`<[T: usize]>` 到 `<[T]>`，如果成功了，则将转换后的值再次从头应用规则进行匹配
   1. `<[T]>::foo(value);` 失败，self 不匹配
   2. `<[T]>::foo(&value);` 成功
   3. `<[T]>::foo(&mut value);` 已经成功，不执行

完成案例代码：

```rust
// lib.rs
// 新增：演示方法调用魔法的模块
pub mod method_resolution_demo {
    use std::ops::{Deref, DerefMut};

    // 1. 演示值方法调用 T::foo(value)
    pub struct ValueType(pub i32);

    impl ValueType {
        pub fn consume_self(self) {
            println!(
                "第1步: ValueType::consume_self(self) - 值被消费: {}",
                self.0
            );
        }
    }

    // 2. 演示引用方法调用 <&T>::foo(value) 和 <&mut T>::foo(value)
    pub struct RefType(pub i32);

    // 注意：我们为 &RefType 实现方法，而不是为 RefType
    impl RefType {
        pub fn ref_method(&self) {
            println!(
                "第2步: RefType::ref_method(&self) - 自动引用转换: {}",
                self.0
            );
        }

        pub fn mut_ref_method(&mut self) {
            println!(
                "第2步: RefType::mut_ref_method(&mut self) - 自动可变引用转换: {}",
                self.0
            );
        }
    }

    // 3. 演示解引用方法调用
    pub struct SmartPointer<T>(T);

    impl<T> SmartPointer<T> {
        pub fn new(value: T) -> Self {
            SmartPointer(value)
        }
    }

    impl<T> Deref for SmartPointer<T> {
        type Target = T;

        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }

    impl<T> DerefMut for SmartPointer<T> {
        fn deref_mut(&mut self) -> &mut Self::Target {
            &mut self.0
        }
    }

    pub struct InnerType(pub i32);

    impl InnerType {
        pub fn inner_method(&self) {
            println!(
                "第3步: InnerType::inner_method(&self) - 解引用调用: {}",
                self.0
            );
        }
    }

    // 4. 演示定长到不定长转换
    pub trait ArrayMethod {
        fn array_method(&self);
    }

    // 为切片实现方法
    impl ArrayMethod for [i32] {
        fn array_method(&self) {
            println!(
                "第4步: [i32]::array_method(&self) - 定长转不定长, 长度: {}",
                self.len()
            );
        }
    }
}


// main.rs
use test_advance::method_resolution_demo::*;

fn main() {
    println!("=== Rust 方法调用的魔法过程演示 ===\n");

    // 第1步：值方法调用 T::foo(value)
    println!("=== 第1步：值方法调用 T::foo(value) ===");
    let value_type = ValueType(42);
    // 编译器首先尝试：ValueType::consume_self(value_type)
    value_type.consume_self(); // 等价于 ValueType::consume_self(value_type)
    println!("✅ 成功：直接找到了 ValueType::consume_self(self)\n");

    // 第2步：引用方法调用 <&T>::foo(value) 和 <&mut T>::foo(value)
    println!("=== 第2步：引用方法调用（自动引用） ===");
    let ref_type = RefType(100);
    // 编译器尝试：RefType::ref_method(ref_type) -> 失败
    // 然后尝试：RefType::ref_method(&ref_type) -> 成功！
    ref_type.ref_method(); // 等价于 RefType::ref_method(&ref_type)
    println!("✅ 成功：编译器自动添加了 & 引用\n");

    let mut mut_ref_type = RefType(200);
    // 类似地，编译器会尝试添加 &mut
    mut_ref_type.mut_ref_method(); // 等价于 RefType::mut_ref_method(&mut mut_ref_type)
    println!("✅ 成功：编译器自动添加了 &mut 引用\n");

    // 第3步：解引用方法调用
    println!("=== 第3步：解引用方法调用 ===");
    let smart_ptr = SmartPointer::new(InnerType(300));
    // 编译器尝试：SmartPointer::inner_method(smart_ptr) -> 失败
    // 尝试：SmartPointer::inner_method(&smart_ptr) -> 失败
    // 尝试：SmartPointer::inner_method(&mut smart_ptr) -> 失败
    // 然后尝试解引用：SmartPointer deref 成功，得到 &InnerType
    // 尝试 InnerType::inner_method(&inner_type_value) -> 成功
    smart_ptr.inner_method();
    // 等价于下面两句
    // let inner_value: &InnerType = smart_ptr.deref();
    // <InnerType>::inner_method(inner_value);
    println!("✅ 成功：编译器通过 Deref 解引用找到了方法\n");

    // 第4步：定长到不定长转换
    println!("=== 第4步：定长到不定长转换 ===");
    let array: [i32; 3] = [1, 2, 3];
    // 尝试：<[i32; 3]>::array_method(array); -> 失败
    // 尝试：<[i32; 3]>::array_method(&array); -> 失败
    // 尝试：<[i32; 3]>::array_method(&mut array); -> 失败
    // 尝试解引用：无法解引用
    // 尝试定长到不定长类型转换：[i32; 3] -> [i32] -> 成功！
    // 尝试在不定长类型上进行调用：
    // <[i32]>::array_method(array); // 失败
    // <[i32]>::array_method(&array); // 成功
    array.array_method(); // 等价于 <[i32]>::array_method(&array)
    println!("✅ 成功：编译器将定长数组转换为切片\n");
}
```

## 高危类型转换

任意类型转换:

- `mem::transmute<T, U>`：将类型 `T` 直接转成类型 `U`，唯一的要求就是，这两个类型占用同样大小的字节数
- `mem::transmute_copy<T, U>`：它从 `T` 类型中拷贝出 `U` 类型所需的字节数，然后转换成 `U` 类型

一个简单样例：

```rust
fn foo() -> i32 {
    0
}

let pointer = foo as *const ();
let function = unsafe {
    // 将裸指针转换为函数指针
    std::mem::transmute::<*const (), fn() -> i32>(pointer)
};
assert_eq!(function(), 0);
```

改变生命周期：

```rust
struct R<'a>(&'a i32);

// 将 'b 生命周期延长至 'static 生命周期
unsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {
    std::mem::transmute::<R<'b>, R<'static>>(r)
}

// 将 'static 生命周期缩短至 'c 生命周期
unsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>) -> &'b mut R<'c> {
    std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)
}
```
