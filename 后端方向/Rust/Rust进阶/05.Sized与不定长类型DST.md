## ?Sized Trait

Rust 中绝大部分的类型都是满足 Sized Trait，但是类似 Vec、String、Trait 对象等类型都是 DST（Dynamically Sized Types），它们的大小在编译时并不确定，这种类型在默认的泛型约束里面是无法使用的（因为所有的泛型隐式添加了 Sized Trait 约束）：

```rust
trait Draw {
    fn draw(&self);
}

// 我们没有添加 Sized Trait约束，但是编译器会默认给我们添加一个Sized Trait约束
fn process_drawable<T: Draw>(item: &T) {
    item.draw();
}
// 编译器实际上会将其转换为
// fn process_drawable<T: Draw + Sized>(item: &T) {
//     item.draw();
// }

struct Circle {
    radius: f64,
}

impl Draw for Circle {
    fn draw(&self) {
        println!("Drawing a circle with radius: {}", self.radius);
    }
}

fn main() {
    // 创建Draw Trait对象
    let drawable: &dyn Draw = &Circle { radius: 5.0 };
    // 传入 Trait 对象
    process_drawable(drawable);
}
```

上述的例子中，由于我们传入的是 Trait 对象，编译器是无法确定具体类型的，也就无法确定类型 T 的大小，加上泛型约束 T: Sized，最终导致 T 类型不满足 Sized Trait 的约束，编译器会报错。

因此，我们需要使用 `?Sized` 来放宽这个限制：

```rust
// 取消 Sized Trait 约束
fn process_drawable<T: Draw + ?Sized>(item: &T) {
    item.draw();
}
```

这个语法是 Rust 中专为泛型场景下取消 Sized 设计的，其他任何地方都不能使用。
