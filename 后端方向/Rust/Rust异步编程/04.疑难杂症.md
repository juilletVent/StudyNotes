## 在 async 语句块中使用 ?

async 语句块和 async fn 最大的区别就是前者无法显式的声明返回值，在大多数时候这都不是问题，但是当配合 ? 一起使用时，问题就有所不同:

```rust
async fn foo() -> Result<u8, String> {
    Ok(1)
}
async fn bar() -> Result<u8, String> {
    Ok(1)
}
pub fn main() {
    let fut = async {
        foo().await?;
        bar().await?;
        Ok(()) // 无法通过编译，编译器无法推断出 Result<T, E> 中的 E 的类型
        // Ok::<(), String>(()) // 使用完全限定语法进行显式的类型注释
    };
}
```

## async 函数和 Send 特征

多线程场景下，在 async 上下文中，非线程安全的类型，词法作用域内只要没有 `.await` 调用，那么就是安全的，可以通过编译：

```rust
use std::rc::Rc;

#[derive(Default)]
struct NotSend(Rc<()>);

async fn foo() {
    {
        let x = NotSend::default();
        // 通过限定词法作用域，x 在此处被drop，因此没有x被发送到其它线程的可能性，也就不会影响 await 的调用
    }
    bar().await;
}
```

词法作用域内包含了 await 调用的类型，必须实现 Send 特征，否则无法通过编译，因为他无法安全的发送到其他线程上。

## 异步递归函数

这 TM 属于天坑了，五星理解难度...

假设我们有这样的异步函数实现：

```rust
async fn recursive() {
    recursive().await;
    recursive().await;
}
// 上面的代码大概会被编译成下面的类型：
enum Recursive {
    First(Recursive),
    Second(Recursive),
}
```

可以观察到，这是一个递归嵌套类型，显然这是一个 DST 类型，无法放到栈上，因此无法通过编译：

```shell
error[E0733]: recursion in an `async fn` requires boxing
 --> src/lib.rs:1:22
  |
1 | async fn recursive() {
  |                      ^ an `async fn` cannot invoke itself directly
  |
  = note: a recursive `async fn` must be rewritten to return a boxed future.
```

为了解决这种问题，我们只能将 recursive 转变成一个正常的函数，该函数返回一个使用 Box 包裹的 async 语句块：

```rust
use futures::future::{BoxFuture, FutureExt};

fn recursive() -> BoxFuture<'static, ()> {
    async move {
        recursive().await;
        recursive().await;
    }.boxed()
}
```

## 在 Trait 中使用 async

在目前版本中，我们还无法在特征中定义 async fn 函数，不过大家也不用担心，目前已经有计划在未来移除这个限制了。

```rust
trait Test {
    // 编译错误
    async fn test();
}
```

借助 async-trait 库，我们可以实现在 Trait 中定义 async fn 函数：

```rust
use async_trait::async_trait;

#[async_trait]
trait Advertisement {
    async fn run(&self);
}

struct Modal;

#[async_trait]
impl Advertisement for Modal {
    async fn run(&self) {
        self.render_fullscreen().await;
        for _ in 0..4u16 {
            remind_user_to_join_mailing_list().await;
        }
        self.hide_for_now().await;
    }
}

struct AutoplayingVideo {
    media_url: String,
}

#[async_trait]
impl Advertisement for AutoplayingVideo {
    async fn run(&self) {
        let stream = connect(&self.media_url).await;
        stream.play().await;

        // 用视频说服用户加入我们的邮件列表
        Modal.run().await;
    }
}
```

性能开标：每一次特征中的 async 函数被调用时，都会产生一次堆内存分配，如果是高频函数，这里可能会成为性能瓶颈。
