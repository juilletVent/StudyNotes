## 基础概念

Rust 中的异步编程底层采用协程的概念，与 JS 的 Async/yield 类似，都是协作式的，在执行耗时任务时需要让出执行权。

Rust 并未内置异步运行时，这与其它语言非常不同，当我们需要使用异步编程时，需要自行引入异步运行时，比如社区主流的运行时: `Tokio`

### 如何选择并发/并行模型

- 有大量 IO 任务需要并发运行时，选 async 模型
- 有部分 IO 任务需要并发运行时，选多线程，如果想要降低线程创建和销毁的开销，可以使用线程池
- 有大量 CPU 密集任务需要并行运行时，例如并行计算，选多线程模型，且让线程数等于或者稍大于 CPU 核心数
- 无所谓时，统一选多线程

## Hello Async

在 Cargo 配置中引入依赖：

```toml
[dependencies]
futures = "0.3.31"
```

在 main 函数中简单使用异步函数：

```rust
use futures::executor::block_on;

fn main() {
    let futures = say_hello();
    block_on(futures); // 等待异步函数执行完毕
}

async fn say_hello() {
    println!("Hello in async fn.");
    say_hi().await; // 等待 say_hi 函数执行完毕
}

async fn say_hi() {
    println!("Hi in async fn.");
}

```

在 Rust 中，异步函数的执行会返回一个类似任务对象的概念或者称之为任务都可以，这个任务时需要执行器去消耗掉的，如果没有执行器去执行并消耗掉，那么这个任务压根儿就不会启动，也就不会有任何效果。

因此，当我们执行：`let futures = say_hello();` 时，say_hello 对应的任务并未开启执行，只是创建了一个异步任务，此时，异步任务处于挂起状态，等待执行器去执行。

而当我们执行：`block_on(futures);` 时，执行器会去执行这个异步任务，让出当前的执行权，并等待其执行完毕，当任务执行完毕后，会重新拉起当，继续执行后续逻辑。

### 另外一个案例

```rust
use futures::executor::block_on;

struct Song {
    author: String,
    name: String,
}

async fn learn_song() -> Song {
    Song {
        author: "曲婉婷".to_string(),
        name: String::from("《我的歌声里》"),
    }
}

async fn sing_song(song: Song) {
    println!(
        "给大家献上一首{}的{} ~ {}",
        song.author, song.name, "你存在我深深的脑海里~ ~"
    );
}

async fn dance() {
    println!("唱到情深处，身体不由自主的动了起来~ ~");
}

async fn learn_and_sing() {
    // 这里使用`.await`来等待学歌的完成，但是并不会阻塞当前线程，该线程在学歌的任务`.await`后，完全可以去执行跳舞的任务
    let song = learn_song().await;

    // 唱歌必须要在学歌之后
    sing_song(song).await;
}

async fn async_main() {
    let f1 = learn_and_sing();
    let f2 = dance();

    // `join!`可以并发的处理和等待多个`Future`，若`learn_and_sing Future`被阻塞，那`dance Future`可以拿过线程的所有权继续执行。若`dance`也变成阻塞状态，那`learn_and_sing`又可以再次拿回线程所有权，继续执行。
    // 若两个都被阻塞，那么`async main`会变成阻塞状态，然后让出线程所有权，并将其交给`main`函数中的`block_on`执行器
    futures::join!(f1, f2);
}

fn main() {
    block_on(async_main());
}
```

## 引入运行时（Tokio）

1. 引入 Tokio 运行时依赖

   ```toml
   [dependencies]
   tokio = { version = "1.47.1", features = ["full"] }
   ```

2. 为 Main 添加异步运行注解

   ```rust
   #[tokio::main]
   async fn main() {
       println!("Hello, world!");
   }
   ```

   此时，Main 函数就可以调用异步函数了，而不在需要手动调用 `block_on` 去执行异步任务了。

### 同时运行多个任务

```rust
use std::time::Duration;
use tokio::{spawn, time::sleep};

// 多线程模式
// #[tokio::main(flavor = "multi_thread")]
// 单线程模式
// #[tokio::main(flavor = "current_thread")]
async fn main() {
    let handle1 = spawn(say_hello());
    let handle2 = spawn(say_hi());

    let _ = tokio::join!(handle1, handle2);
    println!("main end");
}

async fn say_hello() {
    // 如果使用线程阻塞休眠，并且Tokio使用单线程模式的话，这里将会导致整个调度器休眠，其他并发任务在休眠期间将无法得到调度
    // 如果使用Tokio的异步休眠，则不会导致整个调度器休眠，其他并发任务在休眠期间将可以得到调度
    // std::thread::sleep(Duration::from_secs(2));
    sleep(Duration::from_secs(2)).await;
    println!("Hello, world!");
}

async fn say_hi() {
    println!("Hi, world!");
}
```
