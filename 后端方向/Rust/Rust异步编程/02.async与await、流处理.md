## async 的生命周期

当异步函数参数存在引用类型时，需要注意，异步函数背后的 Future 生命周期会被这些引用参数的生命周期限制。

```rust
async fn foo(x: &u8) -> u8 { *x }

// 上面的函数跟下面的函数是等价的:
fn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {
    async move { *x }
}
```

在一般情况下，在函数调用后就立即 .await 不会存在任何问题，例如 foo(&x).await。但是，若 Future 被先存起来或发送到另一个任务或者线程，就可能存在问题了:

```rust
use std::future::Future;
fn bad() -> impl Future<Output = u8> {
    let x = 5;
    // 此处并未进行await，而是直接返回了Future，显然这个Future的生命周期比局部变量 x 要更长
    borrow_x(&x) // ERROR: `x` does not live long enough
}

// 鬼知道Future要等待多久
async fn borrow_x(x: &u8) -> u8 { *x }
```

一个简单的办法：将所需的引用与 Future 绑定在一起，这样 Future 的生命周期就与引用的生命周期一致了：

```rust
use std::future::Future;

async fn borrow_x(x: &u8) -> u8 { *x }

fn good() -> impl Future<Output = u8> {
    async {
        let x = 5;
        borrow_x(&x).await
    }
}
```

## async move

async 语句块允许我们像闭包一样使用 move 关键字来捕获变量，从而延长其生命周期。

```rust
// 多个不同的 `async` 语句块可以访问同一个本地变量，只要它们在该变量的作用域内执行
async fn blocks() {
    let my_string = "foo".to_string();

    let future_one = async {
        // ...
        println!("{my_string}");
    };

    let future_two = async {
        // ...
        println!("{my_string}");
    };

    // 运行两个 Future 直到完成
    let ((), ()) = futures::join!(future_one, future_two);
}


// 由于 `async move` 会捕获环境中的变量，因此只有一个 `async move` 语句块可以访问该变量，
// 但是它也有非常明显的好处： 变量可以转移到返回的 Future 中，不再受借用生命周期的限制
fn move_block() -> impl Future<Output = ()> {
    let my_string = "foo".to_string();
    async move {
        // ...
        println!("{my_string}");
    }
}
```

## 多线程执行器与 `.await`

当使用多线程 Future 执行器( executor )时， Future 可能会在线程间被移动，因此 async 语句块中的变量必须要能在线程间传递。 至于 Future 会在线程间移动的原因是：它内部的任何.await 都可能导致它被切换到一个新线程上去执行。

由于需要在多线程环境使用，意味着 Rc、 RefCell 、没有实现 Send 的所有权类型、没有实现 Sync 的引用类型，它们都是不安全的，因此无法被使用。

类似的原因，在 .await 时使用普通的锁也不安全，例如 Mutex 。原因是，它可能会导致线程池被锁：当一个任务获取锁 A 后，若它将线程的控制权还给执行器，然后执行器又调度运行另一个任务，该任务也去尝试获取了锁 A ，结果当前线程会直接卡死，最终陷入死锁中。

因此，为了避免这种情况的发生，**我们需要使用 futures 包下的锁 futures::lock 来替代 Mutex 完成任务**。
