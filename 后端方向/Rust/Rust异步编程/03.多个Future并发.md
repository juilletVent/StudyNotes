## join!

它允许我们同时等待多个不同 Future 的完成，且可以并发地运行这些 Future。

```rust
// 一个普通版本的异步处理，所有Future串行处理
async fn enjoy_book_and_music() -> (Book, Music) {
    let book = enjoy_book().await;
    let music = enjoy_music().await;
    (book, music)
}
```

但是听歌与看书是两个独立的事件，可以并发处理，因此我们可以使用 join! 来并发处理这两个 Future。

```rust
// 使用 join! 并发处理两个 Future
async fn enjoy_book_and_music() -> (Book, Music) {
    let (book, music) = futures::join!(enjoy_book(), enjoy_music());
    (book, music)
}
```

_Tips: 如果希望同时运行一个数组里的多个异步任务，可以使用 **futures::future::join_all** 方法_

## try_join!

在某一个 Future 报错后就立即停止所有 Future 的执行:

```rust
use futures::try_join;

async fn get_book() -> Result<Book, String> { /* ... */ Ok(Book) }
async fn get_music() -> Result<Music, String> { /* ... */ Ok(Music) }

async fn get_book_and_music() -> Result<(Book, Music), String> {
    let book_fut = get_book();
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}
```

try_join! 要求 Future 返回的 Result 类型中的 Err 类型必须一致，如果不一致，则需要进行 Err 映射：

```rust
use futures::{
    future::TryFutureExt,
    try_join,
};

async fn get_book() -> Result<Book, ()> { /* ... */ Ok(Book) }
async fn get_music() -> Result<Music, String> { /* ... */ Ok(Music) }

async fn get_book_and_music() -> Result<(Book, Music), String> {
    // 需要将 get_book 返回的 Err 类型映射为 String
    let book_fut = get_book().map_err(|()| "Unable to get book".to_string());
    let music_fut = get_music();
    try_join!(book_fut, music_fut)
}
```

## select!

同时等待多个 Future ，且任何一个 Future 结束后，都可以立即被处理:

```rust
use futures::{
    future::FutureExt, // for `.fuse()`
    pin_mut,
    select,
};

async fn task_one() { /* ... */ }
async fn task_two() { /* ... */ }

async fn race_tasks() {
    // fuse 方法为Future实现FusedFuture Trait，只有实现了FusedFuture Trait，select才可以配合loop一起使用
    // 假如没有实现，就算一个 Future 已经完成了，它依然会被 select 不停的轮询执行。
    let t1 = task_one().fuse();
    let t2 = task_two().fuse();

    // 由于 select 不会通过拿走所有权的方式使用 Future，而是通过可变引用的方式去使用，这样当 select 结束后
    // 该 Future 若没有被完成，它的所有权还可以继续被其它代码使用
    pin_mut!(t1, t2); // 为future实现Unpin Trait

    select! {
        // 特殊语法，t1完成后的值赋值给匿名单元类型，然后执行后面的分支逻辑
        // 对于没有返回值的Future可以使用这种写法，如果有返回值，但是明确要忽略的话应该采用
        // _ = t1 => println!("任务1率先完成"),
        () = t1 => println!("任务1率先完成"),
        () = t2 => println!("任务2率先完成"),
    }
}
```

一般来说单纯的并发竞争完成场景很少，更多的是等待所有任务都完成，如果单个任务有后处理，则可以考虑使用 select! + loop 来提高后处理的及时性：

```rust
use futures::future;
use futures::select;
pub fn main() {
    let mut a_fut = future::ready(4);
    let mut b_fut = future::ready(6);
    let mut total = 0;

    loop {
        select! {
            // 特殊语法，a = a_fut 表示将 a_fut 完成后值赋值给 a，然后执行后面的分支逻辑
            a = a_fut => total += a,
            b = b_fut => total += b,
            complete => break,
            default => panic!(), // 该分支永远不会运行，因为 `Future` 会先运行，然后是 `complete`
        };
    }
    assert_eq!(total, 10);
}
```
