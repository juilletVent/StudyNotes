## 类型别名

Rust 中我们可以使用`type`关键字为已有的类型创建别名，别名可以提高代码的可读性，别名与原类型可以互换使用。

```rust
type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;
println!("x + y = {}", x + y);
```

类型别名最主要的用途：减少代码字符重复

```rust
type Thunk = Box<dyn Fn() + Send + 'static>;

let f: Thunk = Box::new(|| println!("hi"));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -> Thunk {
    Box::new(|| println!("hi"))
}
```

## 永不返回的 never 类型

Rust 中有一个特殊的类型：`!`，它代表永远不会返回的值，通常用于表示函数永远不会返回，或者在某些情况下，表示函数会 panic。

```rust
fn bar() -> ! { // panic 引发异常，此函数永远不可能返回
  panic!("You should never see this line!");
}

let guess: u32 = match guess.trim().parse() {
  Ok(num) => num,
  Err(_) => continue, // 此处会返回一个never类型，所以guess的类型是u32，并且不会为guess赋值
};

loop { // 无限循环的loop语句，返回一个never类型
  print!("and ever ");
}
```

## 函数指针

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}
// 接收函数指针作为参数
fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}
fn main() {
    let answer = do_twice(add_one, 5);
    println!("The answer is: {}", answer);
}
```

与闭包不同，fn 是一个类型而不是一个 trait。因此，我们可以直接指定 fn 为参数类型，而不用声明一个以 Fn trait 为约束的泛型参数。

函数指针实现了全部 3 种闭包 trait（Fn、FnMut 以及 FnOnce），所以我们总是可以把函数指针用作参数传递给一个接收闭包的函数。

对于只想接收函数指针类型的参数，则使用上述 `fn` 类型的参数即可，对于希望同时接收函数指针和闭包的参数，则需要使用泛型 + `trait` 作为参数类型。

### 使用 Trait 成员方法作为参数

```rust
fn main() {
    let arr = [1, 2, 3, 4, 5];
    // 此处Map使用完全限定语法传入了一个trait方法作为参数
    let str_arr: Vec<String> = arr.iter().map(MyToString::my_to_string).collect();
    println!("strArr: {:#?}", str_arr);
}

trait MyToString {
    fn my_to_string(&self) -> String;
}

impl MyToString for i32 {
    fn my_to_string(&self) -> String {
        format!("my_to_string: {}", self)
    }
}
```

由于 map 传入了一个 Trait 方法作为参数，所以需要调用 map 的数据集合类型实现了该 Trait，否则将导致错误，这会使得所有元素都会调用该 Trait 方法，这种写法是闭包写法的一种语法糖等价下面的写法：

```rust
fn main() {
    let arr = [1, 2, 3, 4, 5];
    // 使用闭包写法
    let str_arr: Vec<String> = arr.iter().map(|x| x.my_to_string()).collect();
    println!("strArr: {:#?}", str_arr);
}
```

### 使用元组结构体的构造函数作为参数

```rust
#[derive(Debug)]
enum Status {
    Value(u32),
    Stop,
}

fn main() {
    // 传入元组变体构造函数作为参数，这将使得所有元素都将调用该构造函数，并产生Value变体
    let list_of_statuses: Vec<Status> = (0u32..20).map(Status::Value).collect();
    println!("list_of_statuses: {:#?}", list_of_statuses);
}
```

## 返回闭包

对于需要返回闭包的场景，可以参考下面的写法，使用 Trait 对象作为返回值类型，这使得返回值的内存大小可以计算，让编译顺利通过。

```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
  Box::new(|x| x + 1)
}
```

在 2018 年过后，可以使用新的最佳实践写法，这种写法为零开销抽象（no-cost abstraction）：

```rust
// 引入了 impl Trait 作为返回类型
fn returns_closure() -> impl Fn(i32) -> i32 {
    |x| x + 1
}
```
